% -------------------------------------------------
% Arara -- the cool TeX automation tool
% Copyright (c) 2012, Paulo Roberto Massa Cereda
% All rights reserved.
%
% Redistribution and  use in source  and binary forms, with  or without
% modification, are  permitted provided  that the  following conditions
% are met:
%
% 1. Redistributions  of source  code must  retain the  above copyright
% notice, this list of conditions and the following disclaimer.
%
% 2. Redistributions in binary form  must reproduce the above copyright
% notice, this list  of conditions and the following  disclaimer in the
% documentation and/or other materials provided with the distribution.
%
% 3. Neither  the name  of the  project's author nor  the names  of its
% contributors may be used to  endorse or promote products derived from
% this software without specific prior written permission.
%
% THIS SOFTWARE IS  PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS
% "AS IS"  AND ANY  EXPRESS OR IMPLIED  WARRANTIES, INCLUDING,  BUT NOT
% LIMITED  TO, THE  IMPLIED WARRANTIES  OF MERCHANTABILITY  AND FITNESS
% FOR  A PARTICULAR  PURPOSE  ARE  DISCLAIMED. IN  NO  EVENT SHALL  THE
% COPYRIGHT HOLDER OR CONTRIBUTORS BE  LIABLE FOR ANY DIRECT, INDIRECT,
% INCIDENTAL, SPECIAL, EXEMPLARY,  OR CONSEQUENTIAL DAMAGES (INCLUDING,
% BUT  NOT LIMITED  TO, PROCUREMENT  OF SUBSTITUTE  GOODS OR  SERVICES;
% LOSS  OF USE,  DATA, OR  PROFITS; OR  BUSINESS INTERRUPTION)  HOWEVER
% CAUSED AND  ON ANY THEORY  OF LIABILITY, WHETHER IN  CONTRACT, STRICT
% LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
% WAY  OUT  OF  THE USE  OF  THIS  SOFTWARE,  EVEN  IF ADVISED  OF  THE
% POSSIBILITY OF SUCH DAMAGE.
% -------------------------------------------------

\documentclass[a4paper,twoside,12pt]{memoir}

% packages
% -------------------------------------------------
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{arara}
% -------------------------------------------------

% current version
% -------------------------------------------------
\newcommand{\araraversion}{1.0.1}
% -------------------------------------------------

% document
% -------------------------------------------------
\begin{document}

\frontmatter

% title page
% -------------------------------------------------
\begin{titlingpage}

\begin{center}
\vspace*{3em}

\includegraphics[scale=.7]{imgs/araralogo.pdf}

\vspace{2em}

{\color{araracolor}\fontfamily{fco}\bfseries\Huge The cool \TeX{} automation tool}

\vspace{15em}

\begin{mdframed}[innertopmargin=10pt,innerbottommargin=10pt,innerleftmargin=10pt,innerrightmargin=10pt,roundcorner=5pt,linecolor=araracolor,middlelinewidth=2pt]
{\color{araracolor}\fontfamily{fco}\bfseries\Huge\Forward\hfill User Manual}
\end{mdframed}

\vfill

{\color{araracolor}\fontfamily{fco}\bfseries\LARGE Version \araraversion}

\end{center}

\end{titlingpage}
% -------------------------------------------------

% set styles
% -------------------------------------------------
\chapterstyle{ararastyle}
\pagestyle{araraheadings}
% -------------------------------------------------

% Prologue
% -------------------------------------------------
\chapter*{Prologue}
\label{chap:prologue}

\epigraph{\emph{Knowledge brings fear.}}{From a Futurama episode}

Dear reader, please be warned. At first, Arara was written for helping me with my \LaTeX\ projects. To be honest, I never intended to release it to the whole world, since I wasn't sure if other people could benefit from Arara's features. After all, there's already a plethora of tools available to the \TeX\ community in general. The reason I decided to make Arara publicly available is quite simple: I want to contribute to the \TeX\ community, and I want to give my best to make it even more awesome.

That said, here comes the friendly warning: \textsc{Hic Sunt Dracones}. Arara is far from being bug-free. I don't even dare telling that the code is stable -- although I actually think it is. Besides, you will see that Arara gives you enough rope. In other words, \emph{you} will be responsible for how Arara behaves and all the consequences from your actions. Sorry to sound scary, but I really needed to tell you this. After all, one of Arara's features is the freedom it offers. But as you know, freedom always comes at a cost. Please, don't send me angry letters -- or emails, perhaps.

Feedback is surely welcome for me to improve this humble tool, just write an e-mail to \url{cereda@users.sf.net} and I'll reply as soon as possible. The source code is fully available at \url{http://github.com/cereda/arara}, feel free to contribute to the project by forking it or sending pull requests. If you want to support \LaTeX{} development by a donation, the best way to do this is donating to the \href{http://www.tug.org/}{\TeX\ Users Group}. Please also consider joining our \TeX\ community at \href{http://tex.stackexchange.com}{StackExchange}.

\vfill

\begin{flushright}
Paulo Roberto Massa Cereda\\
\emph{The author}
\end{flushright}
% -------------------------------------------------

\cleardoublepage

% Special thanks
% -------------------------------------------------
\section*{Special thanks}

I'd like to thank some friends that made Arara possible:

\begin{description}
\item[Andrew Stacey] for testing Arara, providing great user cases, and for suggesting improvements to the program.
\item[Enrico Gregorio] for reviewing the original manual and providing great ideas and suggestions to the manual and to the program itself.
\item[Joseph Wright] for testing it, providing contributed code for Linux and Mac installations, and also blogging about Arara in his personal blog.
\item[Marco Daniel Elke Schubert] for heavily testing Arara, suggesting enhancements to the manual and to the program itself and also providing lots of contributed rules for common tasks.
\item[Patrick Gundlach] for advertising Arara in the official Twitter channel of Dante -- the German \TeX\ User Group.
\end{description}

And at last but not least, to all 
% -------------------------------------------------

\cleardoublepage

% License
% -------------------------------------------------
\section*{License}

Arara is licensed under the \href{http://www.opensource.org/licenses/bsd-license.php}{New BSD License}. It's important to observe that the New BSD License has been verified as a GPL-compatible free software license by the \href{http://www.fsf.org/}{Free Software Foundation}, and has been vetted as an open source license by the \href{http://www.opensource.org/}{Open Source Initiative}.

\vfill

\begin{infobox}[skipabove=\baselineskip plus 2pt minus 1pt]
\noindent{\color{araracolor}\fontfamily{fco}\bfseries arara -- the cool \TeX{} automation tool}

\vspace{.5em}

\noindent Copyright \copyright\ 2012, Paulo Roberto Massa Cereda

\noindent All rights reserved.

\vspace{1em}

\noindent Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

\begin{itemize}
\item Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
\item Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
\end{itemize}

\vspace{1em}

\noindent\textsc{This software is provided by the copyright holders and contributors ``as is'' and any express or implied warranties, including, but not limited to, the implied warranties of merchantability and fitness for a particular purpose are disclaimed. In no event shall the copyright holder or contributors be liable for any direct, indirect, incidental, special, exemplary, or consequential damages (including, but not limited to, procurement of substitute goods or services; loss of use, data, or profits; or business interruption) however caused and on any theory of liability, wheter in contract, strict liability, or tort (including negligence or otherwise) arising in any way out of the use of this software, even if advised of the possibility of such damage.}
\end{infobox}
% -------------------------------------------------

\cleardoublepage

% TOC and list of codes
% -------------------------------------------------
\tableofcontents*

\cleardoublepage

\listofcodes*
% -------------------------------------------------

\mainmatter

% For users
% -------------------------------------------------
\part{For users}
\label{part:users}
% -------------------------------------------------

% Introduction
% -------------------------------------------------
\chapter{Introduction}
\label{chap:intro}

\epigraph{\emph{Pardon me while I fly my aeroplane.}}{From a Monty Python sketch}

Welcome to Arara! I'm glad you were not intimidated by the threatening message in the prologue -- What prologue? Anyway, this chapter is a quick introduction to what you can expect from Arara. Don't be afraid, it will be easy to digest, I promise.

\section{What is Arara?}
\label{sec:whatisarara}

Good question. I've been asking it myself for a quite long time. Since I have to provide an official definition for Arara -- I'm the author, the one to blame -- I'd go with something along these lines:

\begin{quotation}
\noindent\emph{Arara} is a \TeX{} automation tool. But maybe not in the traditional sense, such as existing tools like \href{http://www.phys.psu.edu/~collins/latexmk/}{latexmk} and \href{https://launchpad.net/rubber/}{rubber}. Think of Arara as a personal assistant. It is as powerful as you want it to be. Arara doesn't provide solutions out of the box, but it gives you subsidies to enhance your \TeX{} experience.
\end{quotation}

Well, that was a shot in the dark. I'm sorry for this crude definition, but the truth is: Arara is generic enough to rely on different schemes. Arara will execute what you tell it to execute. How will Arara do this? That's the problem: you are in control, so it depends on you.

Maybe I should provide an example for a better understanding. Consider the \LaTeX\ code presented in Code~\ref{code:hellolatex}. How would you compile \verb|mydoc.tex| in \verb|rubber|, for instance? It's quite easy, a simple \verb|rubber --pdf mydoc| would do the trick. Now, if you try \verb|arara mydoc|, I'm afraid nothing will be generated. Why? Isn't Arara supposed to be a \TeX\ automation tool? Well, Arara doesn't know what to do with your file. You need to tell it. For now, please understand that you need to provide the batteries for Arara to run -- bad analogy perhaps, but that's true. Don't worry, we will come back to this example later in the manual and see how to make Arara produce the desired output.

\begin{code}
\caption{\texttt{mydoc.tex}}
\label{code:hellolatex}
\begin{infobox}[innertopmargin=3pt, innerbottommargin=3pt, innerleftmargin=10pt, innerrightmargin=3pt]
\begin{latex}
\documentclass{article}

\begin{document}

Hello world.

\end{document}
\end{latex}
\end{infobox}
\end{code}

As I keep saying since the first pages of this manual: you are in control of your documents. Arara won't do anything unless you teach it how to do a task and explicitly tell it to execute the task. Introducing the Arara terminology:

\begin{description}
\item[How can I teach Arara to do a task?] \hfill\\ You need to define Arara rules.
\item[How can I tell Arara to execute a task?] \hfill\\ You need to use Arara directives.
\end{description}

That's probably one of the major differences of Arara from other automation tools. With \verb|latexmk| and \verb|rubber|, for example, you have great features out of the box, ready for you to use and abuse -- batteries included. Arara takes a minimalist approach and gives you the simplicity of doing exactly what you want it to do. Nothing more, nothing less.

\section{Features}
\label{sec:features}

There's nothing so special with Arara. It does exactly what you tell it to do. On the other hand, one of the features I like in Arara is the ability to write rules in a human-readable format. You don't need to rely on other formats. Actually, you can write a compiled rule, but I'm almost sure you will never need one.

I like to be in control of my \TeX\ documents -- including running commands many times my heart desires and in the order I want. I can create a complex workflow and Arara will handle it for me -- again, as long as I have the proper rules.

Another feature worth mentioning is the fact that Arara is platform independent. I wrote it in Java, so Arara runs on top of a Java Virtual Machine (\textsc{jvm}), available on all the major operating systems -- in some cases, you might need to install the proper \textsc{jvm}. I tried to keep my code and libraries compatible with older virtual machines -- currently, Java 5, 6, 7 and OpenJDK 6 are supported. But beware, if you write system-specific rules, you will need to adapt them when porting to other operating system.

\section{Common uses}
\label{sec:commonuses}

Arara can be used in complex workflows, like theses and books. You can tell Arara to compile the document, generate indices and apply styles, remove temporary files, compile other \verb|.tex| documents, run MetaPost or MetaFont, create glossaries, call \verb|pdfcrop|, move files, and much more. It's up to you.

Code~\ref{code:exlatexone} contains the Arara workflow I used for an article I recently wrote. Note that the first call to \verb|pdflatex| creates the \verb|.aux| file, then \verb|bibtex| will extract the cited publications. The next calls to \verb|pdflatex| will insert and refine the references.

\begin{code}[h!]
\caption{\texttt{myarticle.tex}}
\label{code:exlatexone}
\begin{infobox}[innertopmargin=3pt, innerbottommargin=3pt, innerleftmargin=10pt, innerrightmargin=3pt]
\begin{latex}
% arara: pdflatex
% arara: bibtex
% arara: pdflatex
% arara: pdflatex
\documentclass[journal]{IEEEtran}
...
\end{latex}
\end{infobox}
\end{code}

Code~\ref{code:exlatextwo} contains another Arara workflow I used for a manual. I had to use a package that required shell escape, so the calls to \verb|pdflatex| had to enable it. Also, I had an index with a custom formatting, then \verb|makeindex| was called with the proper style.

\begin{code}[h!]
\caption{\texttt{mymanual.tex}}
\label{code:exlatextwo}
\begin{infobox}[innertopmargin=3pt, innerbottommargin=3pt, innerleftmargin=10pt, innerrightmargin=3pt]
\begin{latex}
% arara: pdflatex: { shell: yes }
% arara: makeindex: { style: mystyle }
% arara: pdflatex: { shell: yes }
% arara: pdflatex: { shell: yes }
\documentclass{book}
...
\end{latex}
\end{infobox}
\end{code}

Other workflows can be easily created. There can be an arbitrary number of instructions for Arara to execute, so feel free to come up with your own workflow. Arara will handle it for you.

I really hope you like my humble contribution to the \TeX\ community. Let Arara enhance your \TeX\ experience. Have a good read.

\vspace{2em}

\begin{center}
\color{araracolor}\fontfamily{fco}\bfseries\Large Welcome to arara!
\end{center}

\vfill

\begin{infobox}[frametitle={Trivia}]
Arara is a bird, also known as macaw, native to Mexico, Central America, South America, and formerly the Caribbean. Why did I chose this name? Well, araras are colorful, noisy, naughty and very funny. Everybody loves araras. So why can't you love a tool with the very same name?
\end{infobox}
% -------------------------------------------------

% Installation
% -------------------------------------------------
\chapter{Installation}
\label{chap:installation}

\epigraph{\emph{I would like to buy a hamburger.}}{Inspector Jacques Clouseau, The Pink Panther (2006)}

Splendid, so you decided to give Arara a try? This chapter will cover the installation procedure. Well, to be honest, there is nothing much to see here. The provided \verb|.jar| file is a self-contained, batteries-included executable Java file, so it's not an installation per se, but more like a deployment.

\section{Obtaining Arara}
\label{sec:obtainingarara}

First of all, we need to obtain the Arara binary. Go to the \href{http://github.com/cereda/arara}{project repository} and download the current release. The filename to get is \verb|arara.jar|. You can also build Arara from sources, but it's far beyond the scope of this manual.

\section{Deployment}
\label{sec:deployment}

The first step is to create an application folder. Feel free to create a folder anywhere in your computer. It can be \verb|C:\arara|, \verb|/opt/arara| or another location. My setup is usually \verb|C:\paulo\softwares\arara| for Windows machines and \verb|/opt/paulo/arara| for Linux and Mac, but this is of course a matter of personal taste. For convenience, this folder will be called \verb|ARARA_HOME|. Although it's not mandatory, try to avoid folders structures with spaces in the path.

Since Arara is written in Java, it requires a Java Virtual Machine. Do you have one installed? If you are not sure, try running \verb|java -version| in the terminal and see if you get an output similar to the Code~\ref{code:javainstalled}.

\begin{code}[h!]
\caption{Checking if \texttt{java} is installed.}
\label{code:javainstalled}
\begin{infobox}
\begin{verbatim}
$ java -version
java version "1.6.0_24"
OpenJDK Runtime Environment (IcedTea6 1.11.1)
OpenJDK Client VM (build 20.0-b12, mixed mode)
\end{verbatim}
\end{infobox}
\end{code}

If you don't have a proper Java Virtual Machine installed, I suggest you to visit the \href{http://www.java.com}{Java website} and download one, according to your operating system. Installation instructions are also provided.

Now, copy the \verb|.jar| file we have downloaded in the very first step inside the \verb|ARARA_HOME| folder. Don't forget to add \verb|ARARA_HOME| to the system path. Unfortunately, this manual can't cover the path settings, since it's again a matter of personal taste. For my tools, I usually set the path in my local \verb|.bashrc| with \verb|export PATH="$PATH:$ARARA_HOME"|. It's up to you.

The last step for deploying Arara is platform-specific. In order to run Arara, we should run \verb|java -jar arara.jar|, but that is not intuitive. To make our lives easier, we will create a shortcut for this command. If you are in Windows, create a file named \verb|arara.cmd| inside \verb|ARARA_HOME| and add the content from Code~\ref{code:windows}. If you are in Linux or Mac, create a file named \verb|arara| inside \verb|ARARA_HOME| and add the content from Code~\ref{code:unix}. In Linux and Mac, there only one more thing to do: don't forget to add execute permissions for \verb|arara| by running \verb|chmod +x arara|.

\begin{code}
\caption{\texttt{arara.cmd} for Windows.}
\label{code:windows}
\begin{infobox}
\begin{verbatim}
@echo off
java -jar "%~dp0\arara.jar" %*
\end{verbatim}
\end{infobox}
\end{code}

\begin{code}
\caption{\texttt{arara} for Linux and Mac.}
\label{code:unix}
\begin{infobox}
\begin{verbatim}
#!/bin/bash
java -jar "$(dirname "$0")/arara.jar" $*
\end{verbatim}
\end{infobox}
\end{code}

Did you add \verb|ARARA_HOME| to the path? If so, we are good to go. Try running \verb|arara| in the terminal and see if you get the output shown in Code~\ref{code:arararun}.

\begin{code}
\caption{Testing if \texttt{arara} is correctly deployed.}
\label{code:arararun}
\begin{infobox}
\begin{verbatim}
$ arara
  __ _ _ __ __ _ _ __ __ _ 
 / _` | '__/ _` | '__/ _` |
| (_| | | | (_| | | | (_| |
 \__,_|_|  \__,_|_|  \__,_|

Arara 1.0.1 - The cool TeX automation tool
Copyright (c) 2012, Paulo Roberto Massa Cereda
All rights reserved.

usage: arara [file [--log] [--verbose] | --help | --version]
             
 -h,--help      print the help message
 -l,--log       generate a log output
 -v,--verbose   print the command output
 -V,--version   print the application version
\end{verbatim}
\end{infobox}
\end{code}

If the terminal doesn't display the Arara logo and usage, please review the deployment steps. Every step is important in order to make Arara available in your system. If you have any doubts, feel free to contact me.

\section{Updating}
\label{sec:updating}

If there is a newer version of Arara, simply download the \verb|.jar| file and move it inside the \verb|ARARA_HOME| folder, replacing the old one. No further steps are needed, the newer version is already deployed. Try running \verb|arara| in the terminal and see if the version is equal to the one you have downloaded.
% -------------------------------------------------

% Getting started
% -------------------------------------------------
\chapter{Getting started}
\label{chap:gettingstarted}

\epigraph{\emph{Is Batman a scientist?}}{Homer Simpson}

Time for our first contact with Arara! It's important to understand two concepts in which Arara is based: rules and directives. A \emph{rule} is a formal description of how Arara should handle a certain task. For example, if we want to use \verb|pdflatex| with Arara, we should have a rule for that. Once a rule is defined, Arara automatically provides an access layer to that rule through directives. A \emph{directive} is a special comment in the \verb|.tex| file which will tell Arara how it should execute a certain task. A directive can have as many parameters as its corresponding rule has. Don't worry, let's get started with these new concepts.

\section{Rules}
\label{sec:rules}

Do you remember \verb|mydoc.tex| from Code~\ref{code:hellolatex}? When we tried to mimic \verb|rubber| and run \verb|arara mydoc|, nothing happened. We should tell Arara how it should handle this execution. Let's start with the rules.

A rule is a plain text file written in the \textsc{yaml} format. I chose this format because it's cleaner and more intuitive to use than other markup languages, besides of course being a data oriented format. As a bonus, \textsc{yaml} rhymes with the word \emph{camel}, so Arara is environmentally friendly.

The rules must be placed in a special folder inside \verb|ARARA_HOME|. The full path for plain Arara rules is \verb|ARARA_HOME/rules/plain|, so feel free to create this folder structure before proceeding with the reading. Wait a minute, what is a plain rule? Easy, it's a rule written using the \textsc{yaml} format. We can also have compiled rules in the form of \verb|.jar| files to be placed inside \verb|ARARA_HOME/rules/compiled|, but I'm almost sure you will never need to write one of them. This manual doesn't cover compiled rules, please refer to the developer manual for further reference.

The basic structure of a plain Arara rule is presented in Code~\ref{code:yamlrule}.

\begin{code}[h!]
\caption{\texttt{makefoo.yaml}, a basic structure of a plain Arara rule.}
\label{code:yamlrule}
\begin{infobox}[innertopmargin=3pt, innerbottommargin=3pt, innerleftmargin=10pt, innerrightmargin=3pt]
\begin{yaml}
<R>!config<A>
<B>identifier:<A> makefoo
<B>name:<A> MakeFoo
<B>command:<A> makefoo <G>@{<A>file<G>}<A>
<B>arguments:<A> <G>[<A><G>]<A>
\end{yaml}
\end{infobox}
\end{code}

The \verb|!config| keyword (line 1) is mandatory and it must be the first line of a plain Arara rule. The following keys are defined:

\begin{description}
\item[identifier]\hfill\\ This key (line 2) acts as a unique identifier for the rule. It's highly recommended to use lowercase letters without spaces, accents or punctuation symbols. As a convention, if you have an identifier named \verb|makefoo|, the rule filename must be \verb|makefoo.yaml|.
\item[name]\hfill\\ The \verb|name| key (line 3) holds the name of the task. When running Arara, this value will be displayed in the output. In our example, Arara will display \verb|Running MakeFoo| when dealing with this task.
\item[command]\hfill\\ This key (line 4) contains the system command to be executed. It's highly recommended to avoid interactive commands. Prefer those commands that run as a non-interactive mode, mainly because Arara won't output anything in the terminal neither provide user interaction. You probably noticed a strange element \verb|@{file}|: this element is called \emph{orb tag}. For now, just admit they exist. We will come back to them later on, in Section~\ref{sec:orbtags}.
\item[arguments]\hfill\\ The \verb|arguments| key (line 5) is a list. In our example, it has an empty list, denoted as \verb|[]|. You can define as many arguments as your command requires. Check Code~\ref{code:makebar} for an example of a list of arguments.
\end{description}

For more complex rules, we might want to use arguments. Code~\ref{code:makebar} presents a new rule which makes use of them instead of an empty list as we saw in Code~\ref{code:yamlrule}.

\begin{code}[h!]
\caption{\texttt{makebar.yaml}, a rule with arguments.}
\label{code:makebar}
\begin{infobox}[innertopmargin=3pt, innerbottommargin=3pt, innerleftmargin=10pt, innerrightmargin=3pt]
\begin{yaml}
<R>!config<A>
<B>identifier:<A> makebar
<B>name:<A> MakeBar
<B>command:<A> makebar <G>@{<A>one<G>}<A> <G>@{<A>two<G>}<A> <G>@{<A>file<G>}<A>
<B>arguments:<A>
<B>- identifier:<A> one
   <B>flag:<A> -i <G>@{<A>value<G>}<A>
<B>- identifier:<A> two
   <B>flag:<A> -j <G>@{<A>value<G>}<A>
\end{yaml}
\end{infobox}
\end{code}

For every argument in the list, we have a \verb|-| mark and the proper indentation. The required keys for an argument are:

\begin{description}
\item[identifier]\hfill\\ This key (lines 6 and 8) acts as a unique identifier for the argument. It's highly recommended to use lowercase letters without spaces, accents or punctuation symbols.
\item[flag]\hfill\\ The \verb|flag| key (lines 7 and 9) represents the argument value. Please note that we have another orb tag in the definition, \verb|@{value}|. We will discuss them later in Section~\ref{sec:orbtags}.
\end{description}

For now, just keep in mind that Arara uses rules to tell it how to do a certain task. In the next sections, when more concepts are presented, we will come back to this subject. Just a taste of things to come: directives are mapped to rules through orb tags. Don't worry, I'll explain how things work.

\section{Directives}
\label{sec:directives}

A directive is a special comment inserted in the \verb|.tex| file in which you indicate how Arara should behave. You can insert as many directives as you want, and in any position of the \verb|.tex| file. Arara will read the whole file and extract the directives. A directive should be placed in a line of its own, in the form \verb|% arara: <directive>|. There are two types of directives:

\begin{description}
\item[empty directive]\hfill\\ An empty directive has only the rule identifier, as we seen in Section~\ref{sec:rules}. Lines 1 and 3 of Code~\ref{code:directiveslatex} show an example of empty directives. Note that you can supress arguments (line 3 in constrast to line 2), but we will see that Arara assumes that you know exactly what you are doing.
\item[parametrized directive]\hfill\\ A parametrized directive has the rule identifier followed by its arguments. Line 2 of Code~\ref{code:directiveslatex} shows an example of a parametrized directive. Note that the arguments are mapped by their identifiers, not by their positions.
\end{description}

\begin{code}
\caption{Example of directives in a \texttt{.tex} file.}
\label{code:directiveslatex}
\begin{infobox}[innertopmargin=3pt, innerbottommargin=3pt, innerleftmargin=10pt, innerrightmargin=3pt]
\begin{latex}
% arara: makefoo
% arara: makebar: { one: hello, two: bye }
% arara: makebar
\documentclass{article}
...
\end{latex}
\end{infobox}
\end{code}

The arguments are defined according to the rule mapped by the directive. For example, the rule \verb|makebar| (Code~\ref{code:makebar}) has a list of two arguments, \verb|one| and \verb|two|. So you can safely write \verb|makebar: { one: hello }|, but trying to map a nonexisting argument with \verb|makebar: { three: hi }| will raise an error.

If you want to disable an Arara directive, there's no need of removing it from the \verb|.tex| file. Simply replace \verb|% arara:| by \verb|% !arara:| and this directive will be ignored.

Directives are mapped to rules. In Section~\ref{sec:orbtags} we will learn about orb tags and then revisit rules and directives. I hope the concepts will be clearer since we understand what an orb tag is and how it works.

\section{Orb tags}
\label{sec:orbtags}

When I was planning the mapping scheme, I opted for a templating mechanism. I was looking for flexibility, so the \href{http://mvel.codehaus.org}{\textsc{mvel}} library was perfect for the job. I could extend my mapping plans by using the orb tags. An orb tag consists of a \verb|@| character followed by braces \verb|{...}| which contain regular \textsc{mvel} expressions. In particular, Arara uses the \verb|@{}| expression orb, which contains a value expression which will be evaluated to a string, and appended to the output template. For example, the following template \verb|Hello, my name is @{name}| with \verb|name| resolving to \verb|Paulo| will be expanded to \verb|Hello, my name is Paulo|.

When mapping rules, every command argument will be mapped to the form \verb|@{identifier}| with value equals to the content of the \verb|flag| key. There are two reserved orb tags, \verb|@{file}| and \verb|@{value}|. The first one refers to the \verb|.tex| filename argument passed to Arara. The extension is removed, so no matter if Arara is called with \verb|arara mydoc.tex| or \verb|arara mydoc|, \verb|@{file}| will be expanded to \verb|mydoc|. The \verb|@{file}| value can be overriden, but we will discuss it later. The second reserved orb tag \verb|@{value}| is expanded to the argument value passed in the directive. If you have \verb|makebar: { one: hello }|, the \verb|flag| key of argument \verb|one| will be expanded from the original definition \verb|-i @{value}| to \verb|-i hello|. Now \verb|@{one}| contains the expanded \verb|flag| value, which is \verb|-i hello|. All arguments tags are expanded in the rule command. If one of them is not defined in the directive, Arara will admit an empty value, so the \verb|command| flag will be expanded to \verb|makebar -i hello mydoc|. The whole procedure is summarized as follows:

\begin{enumerate}
\item Arara processed a file named \verb|mydoc.tex|.
\item A directive \verb|makebar: { one: hello }| was found, so Arara will look up the rule \verb|makebar.yaml| (Code~\ref{code:makebar}).
\item The argument \verb|one| is defined and has value \verb|hello|, so the corresponding \verb|flag| key will have the orb tag \verb|@{value}| expanded to \verb|hello|. The new value is now added to the template referenced by the \verb|command| key and then \verb|@{one}| is expanded to \verb|-i hello|.
\item The argument \verb|two| is not defined, so the template referenced by the \verb|command| key has \verb|@{two}| expanded to an empty string.
\item There are no more arguments, so the template referenced by the \verb|command| key now expands \verb|@{file}| to \verb|mydoc|.
\item The final command is now \verb|makebar -i hello mydoc|.
\end{enumerate}

There's a reserved directive key named \verb|files|, which is in fact a list. In case you want to override the default \verb|@{file}| value, use the \verb|files| key, like \verb|makebar: { files: [ thedoc ] }|. This will result in \verb|makebar thedoc| instead of \verb|makebar mydoc|.

If you provide more than one file in the list, Arara will replicate the directive for every file found, so  \verb|makebar: { files: [ a, b, c ] }| will result in three commands: \verb|makebar a|, \verb|makebar b| and \verb|makebar c|.

\section{Examples}
\label{sec:examples}

Now that we know about rules, directives and orb tags, it's time to come up with some examples. I know it's not trivial to understand how Arara works, but I'm sure the examples will help with the concepts. Please note that there might have platform-specific rules, so double-check the commands before running them.

\subsection{PDFLaTeX}
\label{sub:pdflatex}

Our first example is to add support to \verb|pdflatex|. My first attempt to write this rule is presented in Code~\ref{code:pdflatexone}.

\begin{code}[h!]
\caption{\texttt{pdflatex.yaml}, first attempt.}
\label{code:pdflatexone}
\begin{infobox}[innertopmargin=3pt, innerbottommargin=3pt, innerleftmargin=10pt, innerrightmargin=3pt]
\begin{yaml}
<R>!config<A>
<B>identifier:<A> pdflatex
<B>name:<A> PDFLaTeX
<B>command:<A> pdflatex -interaction=nonstopmode <G>@{<A>file<G>}<A>.tex
<B>arguments:<A> <G>[<A><G>]<A>
\end{yaml}
\end{infobox}
\end{code}

So far, so good. The \verb|command| flag has the \verb|pdflatex| program and also the flag \verb|-interaction=nonstopmode|, since Arara doesn't provide user interaction. Now we can add the \verb|pdflatex| directive to our \verb|.tex| file, as we can see in Code~\ref{code:helloexampleone}.

\begin{code}[h!]
\caption{\texttt{helloworld.tex}}
\label{code:helloexampleone}
\begin{infobox}[innertopmargin=3pt, innerbottommargin=3pt, innerleftmargin=10pt, innerrightmargin=3pt]
\begin{latex}
% arara: pdflatex
\documentclass{article}

\begin{document}

Hello world.

\end{document}
\end{latex}
\end{infobox}
\end{code}

It's just a matter of calling \verb|arara helloworld.tex| ( you can also provide the \verb|.tex| extension by calling \verb|arara helloworld.tex|) and Arara will process our file, according to the Code~\ref{code:araraoutputone}.

\begin{code}[h!]
\caption{Arara output for \texttt{pdflatex}.}
\label{code:araraoutputone}
\begin{infobox}
\begin{verbatim}
$ arara helloworld
  __ _ _ __ __ _ _ __ __ _
 / _` | '__/ _` | '__/ _` |
| (_| | | | (_| | | | (_| |
 \__,_|_|  \__,_|_|  \__,_|

Running PDFLaTeX... SUCCESS
\end{verbatim}
\end{infobox}
\end{code}

Great, our first rule works like a charm. Once we define a rule, the directive is automatically available for us to call it as many times as we want. What if we make this rule better? Consider the following situation:

\begin{quotation}
\noindent Sometimes, we need to use \verb|\write18| or call a package that makes use of it (for example, \verb|minted|). It's very dangerous to enable shell escape globally, but changing the \verb|pdflatex| call every time we need it sounds boring.
\end{quotation}

Arara has a special treatment for cases like this. In the early stages of development, Arara was able to handle boolean values. Entries with \verb|true| or \verb|false|, \verb|on| or \verb|off|, \verb|yes| and \verb|no| were mapped to boolean values. If you wanted to use \verb|yes| as text, you could explicitly tell Arara that the value was a string by enclosing it with single or double quotes, \verb|'yes'| or \verb|"yes"|. In my humble opinion, it was a good design at first, but it opened a dangerous pitfall: if a certain mapping was expecting a boolean, but another value was received, the result was automatically resolved to \verb|true|. We have enough problems of Arara itself giving us enough rope, so I decided to consider every argument value as string. No big deal, we can still mimic a boolean behaviour, as we will see in our next attempt.

We will rewrite our \verb|pdflatex| rule to include a flag for shell escape. Another cool feature will be presented now, as we can see in the new rule shown in Code~\ref{code:pdflatextwo}.

\begin{code}[h!]
\caption{\texttt{pdflatex.yaml}, second attempt.}
\label{code:pdflatextwo}
\begin{infobox}[innertopmargin=3pt, innerbottommargin=3pt, innerleftmargin=10pt, innerrightmargin=3pt]
\begin{yaml}
<R>!config<A>
<B>identifier:<A> pdflatex
<B>name:<A> PDFLaTeX
<B>command:<A> pdflatex -interaction=nonstopmode <G>@{<A>shell<G>}<A> <G>@{<A>file<G>}<A>.tex
<B>arguments:<A>
<B>- identifier:<A> shell
   <B>flag:<A> '<G>@{<A>value == "yes" ? "-shell-escape" : "-no-shell-escape" <G>}<A>'
\end{yaml}
\end{infobox}
\end{code}

Orb tags allow evaluation inside the tag block! Line 7 from Code~\ref{code:pdflatextwo} makes use of the ternary operator \verb|?:| which defines a conditional expression. In the first part of the evaluation, we check if \verb|value| is equal to the string \verb|"yes"|. If so, \verb|"-shell-escape"| is defined as the result of the operation. If the conditional expression is false, \verb|"-no-shell-escape"| is set instead.

What if you want to allow \verb|true| and \verb|on| as valid options as well? We can easily rewrite our orb tag to check for additional values. It's also possible to invoke some string methods on orb tags, like \verb|toLowerCase|. A third attempt is presented in Code~\ref{code:pdflatexthree}. The \verb|toLowerCase| method was added to allow entries like \verb|Yes|, \verb|yEs| and other combinations. Although Arara can support cases in arguments and values, I recommend you to stick with lowercase entries. By the way, for more complex orb tag schemes, it's important to enclose the orb tags with either single or double quotes. Of course, if you use single quotes to enclose the orb tags, use double quotes for internal evaluations, and vice versa.

\begin{code}[h!]
\caption{\texttt{pdflatex.yaml}, third attempt.}
\label{code:pdflatexthree}
\begin{infobox}[innertopmargin=3pt, innerbottommargin=3pt, innerleftmargin=10pt, innerrightmargin=3pt]
\begin{yaml}
<R>!config<A>
<B>identifier:<A> pdflatex
<B>name:<A> PDFLaTeX
<B>command:<A> pdflatex -interaction=nonstopmode <G>@{<A>shell<G>}<A> <G>@{<A>file<G>}<A>.tex
<B>arguments:<A>
<B>- identifier:<A> shell
   <B>flag:<A> '<G>@{<A>value.toLowerCase() == "yes" || value.toLowerCase() == "true" || value.toLowerCase() == "on" ? "-shell-escape" : "-no-shell-escape" <G>}<A>'
\end{yaml}
\end{infobox}
\end{code}

With this new rule, it's now easy to enable the shell escape option in \verb|pdflatex|. Simply go with the directive \verb|pdflatex: { shell: yes }|. You can also use \verb|true| or \verb|on| instead of \verb|yes|. Any other value for \verb|shell| will disable the shell escape option. It's important to observe that Arara directives have no mandatory arguments. If you want to add a dangerous option like \verb|-shell-escape|, consider calling it as an argument with a proper check and rely on a safe state for the argument fallback.

\subsection{MakeIndex}
\label{sub:makeindex}

For the next example, we will create a rule for \verb|makeindex|. To be honest, although \verb|makeindex| has a lot of possible arguments, I only use the \verb|-s| flag once in a while. Code~\ref{code:makeindexone} shows our first attempt of writing this rule.

\begin{code}[h!]
\caption{\texttt{makeindex.yaml}, first attempt.}
\label{code:makeindexone}
\begin{infobox}[innertopmargin=3pt, innerbottommargin=3pt, innerleftmargin=10pt, innerrightmargin=3pt]
\begin{yaml}
<R>!config<A>
<B>identifier:<A> makeindex
<B>name:<A> MakeIndex
<B>command:<A> makeindex <G>@{<A>style<G>}<A> <G>@{<A>file<G>}<A>.idx
<B>arguments:<A>
<B>- identifier:<A> style
   <B>flag:<A> -s <G>@{<A>value<G>}<A>
\end{yaml}
\end{infobox}
\end{code}

As a follow-up to our fist attempt, we will now add support for the \verb|-g| flag that employs German word ordering in the index. Since this flag is basically a switch, we can borrow the same tactic used for shell escape in the previous example. The new rule is presented in Code~\ref{code:makeindextwo}.

\begin{code}[h!]
\caption{\texttt{makeindex.yaml}, second attempt.}
\label{code:makeindextwo}
\begin{infobox}[innertopmargin=3pt, innerbottommargin=3pt, innerleftmargin=10pt, innerrightmargin=3pt]
\begin{yaml}
<R>!config<A>
<B>identifier:<A> makeindex
<B>name:<A> MakeIndex
<B>command:<A> makeindex <G>@{<A>german<G>}<A> <G>@{<A>style<G>}<A> <G>@{<A>file<G>}<A>.idx
<B>arguments:<A>
<B>- identifier:<A> style
   <B>flag:<A> -s <G>@{<A>value<G>}<A>
<B>- identifier:<A> german
   <B>flag:<A> '<G>@{<A>value.toLowerCase() == "yes" || value.toLowerCase() == "true" || value.toLowerCase() == "on" ? "-g" : "" <G>}<A>'
\end{yaml}
\end{infobox}
\end{code}

The new \verb|makeindex| rule presented in Code~\ref{code:makeindextwo} looks good. We can now test the compilation workflow with an example. Consider a file named \verb|helloindex.tex| which has a few index entries, presented in Code~\ref{code:examplemakeindex}. As usual, I'll present my normal workflow, that involves calling \verb|pdflatex| two times to get references right, one call to \verb|makeindex| and finally, a last call to \verb|pdflatex|. Though there's no need of calling \verb|pdflatex| two times in the beginning, I'll keep that as a good practice from my side.

\begin{code}[h!]
\caption{\texttt{helloindex.tex}}
\label{code:examplemakeindex}
\begin{infobox}[innertopmargin=3pt, innerbottommargin=3pt, innerleftmargin=10pt, innerrightmargin=3pt]
\begin{latex}
% arara: pdflatex
% arara: pdflatex
% arara: makeindex
% arara: pdflatex
\documentclass{article}

\usepackage{makeidx}

\makeindex

\begin{document}

Hello world\index{Hello world}.

Goodbye world\index{Goodbye world}.

\printindex

\end{document}
\end{latex}
\end{infobox}
\end{code}

By running \verb|arara helloindex| or \verb|helloindex.tex| in the terminal, we will obtain the same output from Code~\ref{code:araramakeexample}. The execution order is defined by the directives order in the \verb|.tex| file. If any command fails, Arara halts at that position and nothing else is executed.

You might ask how Arara knows if the command was successfully executed. The idea is quite simple: good programs like \verb|pdflatex| make use of a concept known as exit status. In short, when a program had a normal execution, the exit status is zero. Other values are returned when an abnormal execution happened. When \verb|pdflatex| successfully compiles a \verb|.tex| file, it returns zero, so Arara intercepts this number. Again, it's a good practice to make command line applications return proper exit status according to the execution flow, but beware: you might find applications or shell commands that don't feature this control (in the worst case, the returned value is always zero).

\begin{code}[h!]
\caption{Running \texttt{helloindex.tex}.}
\label{code:araramakeexample}
\begin{infobox}
\begin{verbatim}
$ arara helloindex
  __ _ _ __ __ _ _ __ __ _
 / _` | '__/ _` | '__/ _` |
| (_| | | | (_| | | | (_| |
 \__,_|_|  \__,_|_|  \__,_|

Running PDFLaTeX... SUCCESS
Running PDFLaTeX... SUCCESS
Running MakeIndex... SUCCESS
Running PDFLaTeX... SUCCESS
\end{verbatim}
\end{infobox}
\end{code}

According to the terminal output shown in Code~\ref{code:araramakeexample}, Arara executed all the commands successfully. In Chapter~\ref{chap:logging} we will learn more about how Arara deals with commands and how to get their outputs for a more detailed analysis.

\subsection{Cleaning temporary files}
\label{sub:clean}

After running \verb|arara helloindex| successfully (Code~\ref{code:araramakeexample}), we now have as a result a new \verb|helloindex.pdf| file, but also a lot of auxiliary files, as we can see in Code~\ref{code:lsone}.

\begin{code}[h!]
\caption{List of auxiliary files after running \texttt{arara helloindex}.}
\label{code:lsone}
\begin{infobox}
\begin{verbatim}
$ ls
helloindex.aux  helloindex.ilg  helloindex.log  helloindex.tex
helloindex.idx  helloindex.ind  helloindex.pdf
\end{verbatim}
\end{infobox}
\end{code}

What if we write a new \verb|clean| rule to remove all the auxiliary files? The idea is to use \verb|rm| to remove each one of them. As mentioned in the beginning of the manual, some rules might be system-specific, so this one is a perfect example.

Since we want our rule to be generic enough, it's now a good opportunity to introduce the use of the reserved directive key \verb|files|, first seen in Section~\ref{sec:orbtags}. This special key is a list that overrides the default \verb|@{file}| value and replicates the directive for every element in the list. I'm sure this will be the easiest rule we've written so far. The \verb|clean| rule is presented in Code~\ref{code:cleanone}.

\begin{code}[h!]
\caption{\texttt{clean.yaml}}
\label{code:cleanone}
\begin{infobox}[innertopmargin=3pt, innerbottommargin=3pt, innerleftmargin=10pt, innerrightmargin=3pt]
\begin{yaml}
<R>!config<A>
<B>identifier:<A> clean
<B>name:<A> CleaningTool
<B>command:<A> rm -f <G>@{<A>file<G>}<A>
<B>arguments:<A> <G>[<A><G>]<A>
\end{yaml}
\end{infobox}
\end{code}

Note that the command \verb|rm| has a \verb|-f| flag. As mentioned before, commands return an exit status after their calls. If we try to remove a nonexistent file, \verb|rm| will complain and return a value different than zero. This will make Arara halt and print a big \textsc{failure}  on screen, since it is considered an abnormal execution. If we provide the \verb|-f| flag, \verb|rm| will not complain of a nonexistent file, so we won't be bothered for this trivial task.

Now we need to add the directive to our \verb|helloindex.tex| file (Code~\ref{code:examplemakeindex}). Of course, \verb|clean| will be the last directive, since it will only be reachable if everything executed before was returned no errors. The new header of \verb|helloindex.tex| is presented in Code~\ref{code:examplemakeindextwo}.

\begin{code}[h!]
\caption{\texttt{helloindex.tex} with the new \texttt{clean} directive.}
\label{code:examplemakeindextwo}
\begin{infobox}[innertopmargin=3pt, innerbottommargin=3pt, innerleftmargin=10pt, innerrightmargin=3pt]
\begin{latex}
% arara: pdflatex
% arara: pdflatex
% arara: makeindex
% arara: pdflatex
% arara: clean: { files: [ helloindex.aux, helloindex.idx, helloindex.ilg, helloindex.ind, helloindex.log ] }
\documentclass{article}
...
\end{latex}
\end{infobox}
\end{code}

The reserved directive key \verb|files| has five elements, so the \verb|clean| rule will be replicated five times with the orb tag \verb|@{file}| being expanded to each element. If you wish, you can also evaluate the value through a conditional expression, as we did before with the other rules. In my opinion, I don't think it's necessary for this particular rule.

Time to run \verb|arara helloindex| again and see if our new \verb|clean| rule works! Code~\ref{code:araramakeexampletwo} shows both Arara execution and directory listing. We expect to find only our source \verb|helloindex.tex| and the resulting \verb|helloindex.pdf| file.

\begin{code}[h!]
\caption{Running \texttt{helloindex.tex} with the new \texttt{clean} rule.}
\label{code:araramakeexampletwo}
\begin{infobox}
\begin{verbatim}
$ arara helloindex
  __ _ _ __ __ _ _ __ __ _ 
 / _` | '__/ _` | '__/ _` |
| (_| | | | (_| | | | (_| |
 \__,_|_|  \__,_|_|  \__,_|

Running PDFLaTeX... SUCCESS
Running PDFLaTeX... SUCCESS
Running MakeIndex... SUCCESS
Running PDFLaTeX... SUCCESS
Running CleaningTool... SUCCESS
Running CleaningTool... SUCCESS
Running CleaningTool... SUCCESS
Running CleaningTool... SUCCESS
Running CleaningTool... SUCCESS
$ ls
helloindex.pdf  helloindex.tex
\end{verbatim}
\end{infobox}
\end{code}

Great, the \verb|clean| rule works like a charm! A friendly note: if you are in Windows, replacing \verb|rm| by the equivalent \verb|del| won't probably work. Commands like \verb|del| must be called in the form \verb|cmd /c del|. Make sure to exhaustively test your rules before putting them into production. Check Chapter~\ref{chap:logging} to learn more about tracking the Arara execution.
% -------------------------------------------------

% When something goes on
% -------------------------------------------------
\chapter{When something goes wrong}
\label{chap:logging}

\epigraph{\emph{Don't panic!}}{From The Hitchhiker's\\ Guide to the Galaxy}

One of Arara's goals is to reduce the verbosity of commands. Though the extensive output might contain relevant information about the execution process, in most of the cases it is simply to much stuff going on for us to follow. Besides, commands like \verb|pdflatex| generate a proper \verb|.log| file for us to check how things went. Arara's minimalist approach informs us about the execution status: \textsc{success} or \textsc{failure}. When things go terribly wrong, we need to rely on more than this status. We should ask Arara to keep track of the execution plan for us.

\section{Arara messages}
\label{sec:araramessages}

Arara messages are the first type of feedback provided by Arara. These messages are basically related to rules and directives. Bad syntax, nonexisting rules, malformed directives, wrong expansion, Arara tries to tell you what went wrong. Those messages are usually associated with errors. I tried to include useful messages, like telling in which directive and line an error ocurred, or that a certain rule does not exist or has an incorrect format. Arara also checks if a command is valid. If you try to call a rule that executes a nonexisting \verb|makefoo| command, Arara will complain about it.

\section{Logging}
\label{sec:logging}

Another way of looking for an abnormal behaviour is to read the proper \verb|.log| file. Unfortunately, not every command emits a report of its execution and, even if the command generates a \verb|.log| file, multiple runs would overwrite the previous reports and we would have only the last call. Arara provides a more consistent way of monitoring commands and their own behaviour through a global \verb|.log| file that holds every single bit of information. You can enable the logging feature by adding either the \verb|--log| or \verb|-l| flags to the \verb|arara| application.

Before we continue, I need to explain about standard streams, since they constitute an important part of the generated \verb|.log| file by Arara. \href{http://en.wikipedia.org/wiki/Standard_streams}{Wikipedia} has a nice definition of them:

\begin{quotation}
\noindent ``In computer programming, standard streams are preconnected input and output channels between a computer program and its environment (typically a text terminal) when it begins execution. The three \textsc{i/o} connections are called standard input (\verb|stdin|), standard output (\verb|stdout|) and standard error (\verb|stderr|).''
\end{quotation}

Basically, the operating system provides two streams directed to display data: \verb|stdout| and \verb|stderr|. Usually, the first stream is used by a program to write its output data, while the second one is typically used to output error messages or diagnostics. Of course, the decision of what output stream to use is up to the program author.

When Arara traces a command execution, it logs both \verb|stdout| and \verb|stderr|. The log entry for \verb|stdout| is \texttt{Standard output logging} while \verb|stderr| is referenced by \texttt{Standard error logging}. Again, an output to \verb|stderr| does not necessarily mean that an error was found in the code, while an output to \verb|stdout| does not necessarily mean that everything ran flawlessly. It's just a naming convention, as the program author decides how to handle the messages flow. That's why Arara logs them both. Read the \verb|stdout| and \verb|stderr| log entries carefully. A excerpt of the resulting \verb|arara.log| from \verb|arara helloindex --log| is show in Code~\ref{code:araralog} -- several lines were removed in order to leave only the more important parts.

The Arara log is useful for keeping track of the execution flow as well as providing feedback on how both rules and directives are being expanded. The log file contains information about the directive extraction and parsing, rules checking and expansion, deployment of tasks and execution of commands. The Arara messages are also logged.

\begin{code}[p!]
\caption{\texttt{arara.log} from \texttt{arara helloindex {-}{-}log}.}
\label{code:araralog}
\begin{infobox}
\begin{lstlisting}[basicstyle=\footnotesize\ttfamily, columns=flexible, showspaces=false, breaklines=true]
09 Abr 2012 11:27:58.400 INFO  Arara - Welcome to Arara!
09 Abr 2012 11:27:58.406 INFO  Arara - Processing file helloindex.tex, please wait.
09 Abr 2012 11:27:58.413 INFO  DirectiveExtractor - Reading directives from helloindex.tex.
09 Abr 2012 11:27:58.413 TRACE DirectiveExtractor - Directive found in line 1 with pdflatex.
...
09 Abr 2012 11:27:58.509 INFO  DirectiveParser - Parsing directives.
09 Abr 2012 11:27:58.536 INFO  TaskDeployer - Deploying tasks into commands.
09 Abr 2012 11:27:58.703 INFO  CommandTrigger - Ready to run commands.
09 Abr 2012 11:27:58.704 INFO  CommandTrigger - Running PDFLaTeX.
09 Abr 2012 11:27:58.704 TRACE CommandTrigger - Command: pdflatex -interaction=nonstopmode  helloindex.tex
09 Abr 2012 11:27:59.435 TRACE CommandTrigger - Standard error logging: 
09 Abr 2012 11:27:59.435 TRACE CommandTrigger - Standard output logging: This is pdfTeX, Version 3.1415926-2.3-1.40.12 (TeX Live 2011)
...
Output written on helloindex.pdf (1 page, 12587 bytes).
Transcript written on helloindex.log.
09 Abr 2012 11:27:59.435 INFO  CommandTrigger - PDFLaTeX was successfully executed.
09 Abr 2012 11:27:59.655 INFO  CommandTrigger - Running MakeIndex.
09 Abr 2012 11:27:59.655 TRACE CommandTrigger - Command: makeindex   helloindex.idx
09 Abr 2012 11:27:59.807 TRACE CommandTrigger - Standard error logging: This is makeindex, version 2.15 [TeX Live 2011] (kpathsea + Thai support).
...
Generating output file helloindex.ind..done (9 lines written, 0 warnings).
Output written in helloindex.ind.
Transcript written in helloindex.ilg.
09 Abr 2012 11:27:59.807 TRACE CommandTrigger - Standard output logging: 
09 Abr 2012 11:27:59.807 INFO  CommandTrigger - MakeIndex was successfully executed.
...
09 Abr 2012 11:28:00.132 INFO  CommandTrigger - All commands were successfully executed.
09 Abr 2012 11:28:00.132 INFO  Arara - Done.
\end{lstlisting}
\end{infobox}
\end{code}

If by any chance your code is not working, try to run \verb|arara| with the logging feature enabled. It might take a while for you to digest the log entries, but I'm sure you will be able to track every single step of Arara's execution and fix the offending line in your code.
% -------------------------------------------------

% Best practices
% -------------------------------------------------
\chapter{Best practices}
\label{chap:bestpractices}

\epigraph{\emph{Snakes! Why did it have to be snakes?}}{Indiana Jones,\\ Raiders of the Lost Ark (1981)}

The following list contains some hints on best practices when using Arara. I tried my best to name a few situations and annoyances that you might encounter, but the list is far from being complete and accurate. Feel free to establish your own practices. After all, Arara depends on the user, and not the other way around.

\section{Plain rules}
\label{sec:plainrules}

\begin{description}
\item[Use a text editor with support to {\normalfont\texttt{.yaml}} files]\hfill\\ In my humble opinion, \textsc{yaml} is a great format for expressing Arara rules, but you might encounter problems if the \verb|.yaml| file is not well-formed. Please follow the rule format presented in Section~\ref{sec:rules} and use a text editor with proper support to the \textsc{yaml} format. Personally, I use \href{http://www.vim.org}{Vim} for editing Arara rules.
\item[Use only lowercase letters when defining identifiers for rules]\hfill\\ Avoid at all costs uppercase letters, digits, spaces, punctuation or other symbols when defining the \verb|identifier| key for Arara rules.
\item[Prefer to enclose orb tags with single quotes]\hfill\\ Although you can also enclose orb tags with double quotes, I suggest you to stick with single quotes. Use double quotes inside the orb tag for possible evaluations.
\item[If the key value only contains an orb tag, enclose it]\hfill\\ Compare the \verb|flag| key of the two arguments from the \verb|makeindex| rule (Code~\ref{code:makeindextwo}). When there's only the orb tag as value or if the orb tag comes first in the value, please enclose the whole value with single quotes, like \verb|'@{value}'| or \verb|'@{value} --flag'|. Arara tries to resolve the value type, but sometimes orb tags can mislead the extractor. If you want to play it safe, enclose the value with single quotes.
\item[Don't use reserved keywords as identifiers]\hfill\\ Arara has a few reserved keywords: \verb|file|, \verb|files|, \verb|value| and \verb|arara|. Don't use them as identifiers, otherwise name clashes will make Arara's behaviour unpredictable and mess with the document workflow.
\end{description}

\section{Directives}
\label{sec:directives}

\begin{description}
\item[If an argument value has spaces, enclose it with quotes]\hfill\\ Again, try to avoid at all costs values with spaces, but if you really need them, enclose the value with single quotes. Beware: commands might require you to enclose values with spaces with double quotes! If you try to run the directive \verb|clean: { files: [ 'my doc.aux' ] }|, the command will be expanded to \verb|rm -f my doc.aux| which is wrong! Two files will be removed: \verb|my| and \verb|doc.aux|. The solution is to use double quotes inside the value surround by single quotes, so a call to the directive \verb|clean: { files: [ '"my doc.aux"' ] }| will be expanded to \verb|rm -f "my doc.aux"| which is correct. Another example is the \verb|makeindex| directive. If you have a style named \verb|my style.ist|, you can call it by running \verb|makeindex: { style: '"my style"' }| and the command will be correctly expanded.
\end{description}

\vfill

\begin{infobox}%[frametitle={}]
If you want to make sure that both rules and directives are being mapped and expanded correctly, enable the logging option with the \verb|--log| flag and verify the output. All expansions are logged.
\end{infobox}
% -------------------------------------------------

% For developers
% -------------------------------------------------
\part{For developers}
\label{part:developers}
% -------------------------------------------------

% Writing compiled rules
% -------------------------------------------------
\chapter{Writing compiled rules}
\label{chap:writingcompiledrules}

Hello world.
% -------------------------------------------------

\end{document}
