% -------------------------------------------------
% Arara -- the cool TeX automation tool
% Copyright (c) 2012, Paulo Roberto Massa Cereda
% All rights reserved.
%
% Redistribution and  use in source  and binary forms, with  or without
% modification, are  permitted provided  that the  following conditions
% are met:
%
% 1. Redistributions  of source  code must  retain the  above copyright
% notice, this list of conditions and the following disclaimer.
%
% 2. Redistributions in binary form  must reproduce the above copyright
% notice, this list  of conditions and the following  disclaimer in the
% documentation and/or other materials provided with the distribution.
%
% 3. Neither  the name  of the  project's author nor  the names  of its
% contributors may be used to  endorse or promote products derived from
% this software without specific prior written permission.
%
% THIS SOFTWARE IS  PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS
% "AS IS"  AND ANY  EXPRESS OR IMPLIED  WARRANTIES, INCLUDING,  BUT NOT
% LIMITED  TO, THE  IMPLIED WARRANTIES  OF MERCHANTABILITY  AND FITNESS
% FOR  A PARTICULAR  PURPOSE  ARE  DISCLAIMED. IN  NO  EVENT SHALL  THE
% COPYRIGHT HOLDER OR CONTRIBUTORS BE  LIABLE FOR ANY DIRECT, INDIRECT,
% INCIDENTAL, SPECIAL, EXEMPLARY,  OR CONSEQUENTIAL DAMAGES (INCLUDING,
% BUT  NOT LIMITED  TO, PROCUREMENT  OF SUBSTITUTE  GOODS OR  SERVICES;
% LOSS  OF USE,  DATA, OR  PROFITS; OR  BUSINESS INTERRUPTION)  HOWEVER
% CAUSED AND  ON ANY THEORY  OF LIABILITY, WHETHER IN  CONTRACT, STRICT
% LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
% WAY  OUT  OF  THE USE  OF  THIS  SOFTWARE,  EVEN  IF ADVISED  OF  THE
% POSSIBILITY OF SUCH DAMAGE.
% -------------------------------------------------

\documentclass[a4paper,twoside,12pt]{memoir}

% packages
% -------------------------------------------------
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{arara}
% -------------------------------------------------

% current version
% -------------------------------------------------
\newcommand{\araraversion}{2.0}
% -------------------------------------------------

% document
% -------------------------------------------------
\begin{document}

% title page
% -------------------------------------------------
\begin{titlingpage}

\begin{center}
\vspace*{3em}

\includegraphics[scale=.7]{araralogo.pdf}

\vspace{2em}

{\color{araracolor}\fontfamily{fco}\bfseries\Huge The cool \TeX{} automation tool}

\vspace{15em}

\begin{mdframed}[innertopmargin=10pt,innerbottommargin=10pt,innerleftmargin=10pt,%
                innerrightmargin=10pt,roundcorner=5pt,linecolor=araracolor,%
                middlelinewidth=2pt]
{\color{araracolor}\fontfamily{fco}\bfseries\Huge\Forward\hfill User Manual}
\end{mdframed}

\vfill

{\color{araracolor}\fontfamily{fco}\bfseries\LARGE Version \araraversion}

\end{center}

\end{titlingpage}
% -------------------------------------------------

% set styles
% -------------------------------------------------
\frontmatter
\chapterstyle{ararastyle}
\pagestyle{araraheadings}
% -------------------------------------------------

% Prologue
% -------------------------------------------------
\chapter*{Prologue}
\label{chap:prologue}

\epigraph{\emph{Knowledge brings fear.}}{From a Futurama episode}

Dear reader, please be warned. At first, \arara was written for helping me with
my \LaTeX\ projects. To be honest, I never intended to release it to the whole 
world, since I wasn't sure if other people could benefit from \arara's features.
After all, there's already a plethora of tools available to the \TeX\ community 
in general. The reason I decided to make \arara publicly available is quite 
simple: I want to contribute to the \TeX\ community, and I want to give my best 
to make it even more awesome.

That said, here comes the friendly warning: \textsc{Hic Sunt Dracones}. \arara 
is far from being bug-free. I don't even dare telling that the code is stable -- 
although I actually think it is. Besides, you will see that \arara gives you 
enough rope. In other words, \emph{you} will be responsible for how \arara 
behaves and all the consequences from your actions. Sorry to sound scary, but I 
really needed to tell you this. After all, one of \arara's features is the 
freedom it offers. But as you know, freedom always comes at a cost. Please, 
don't send me angry letters -- or emails, perhaps.

Feedback is surely welcome for me to improve this humble tool, just write an 
e-mail to \url{cereda@users.sf.net} and I'll reply as soon as possible. The 
source code is fully available at \url{http://github.com/cereda/arara}, feel 
free to contribute to the project by forking it or sending pull requests. If you 
want to support \LaTeX{} development by a donation, the best way to do this is 
donating to the \href{http://www.tug.org/}{\TeX\ Users Group}. Please also 
consider joining our \TeX\ community at 
\href{http://tex.stackexchange.com}{StackExchange}.

\vfill

\begin{flushright}
Paulo Roberto Massa Cereda\\
\emph{The author}
\end{flushright}
% -------------------------------------------------

\cleardoublepage

% Special thanks
% -------------------------------------------------
\section*{Special thanks}

I'd like to thank some friends that made \arara possible:

\begin{description}
\item[Andrew Stacey] for testing \arara, providing great user cases, and for 
                     suggesting improvements to the program.
\item[Enrico Gregorio] for reviewing the original manual and providing great 
                       ideas and suggestions to the manual and to the program 
                       itself.
\item[Joseph Wright] for testing it, providing contributed code for Linux and Mac
                     installations, and also blogging about \arara in his 
                     \href{http://www.texdev.net}{personal blog}.
\item[Marco Daniel] for heavily testing \arara, suggesting enhancements to the 
                    manual and to the program itself and also providing lots of 
                    contributed rules for common tasks. Marco is now an official
                    collaborator and is helping me a lot with the project
                    management. I have no words to express my gratitude for what
                    Marco has been doing to \arara.
\item[Patrick Gundlach] for advertising \arara in the official Twitter channel 
                        of Dante -- the German \TeX\ User Group.
\end{description}

And at last but not least, I want to thank you, dear reader and potential user, for giving \arara a try. It's been an honour to serve the \TeX\ community.
% -------------------------------------------------

\cleardoublepage

% Release information
% -------------------------------------------------
\section*{Release information}

\subsection*{2.0}
\begin{itemize}
\item[\featurenew] TODO.
\item[\featurefixed] TODO.
\end{itemize}
\subsection*{1.0.1}

\begin{itemize}
\item[\featurenew] Added support for |.tex|, |.dtx| and |.ltx| files. When no extension is provided, \arara will automatically look for these extensions in this specific order.
\item[\featurenew] Added the |--verbose| flag to allow printing the complete log in the terminal. A short |-v| tag is also available. Both |stdout| and |stderr| are printed.
\item[\featurefixed] Fixed exit status when an exception is thrown. Now \arara also returns a non-zero exit status when something wrong happened. Note that this behaviour happens only when \arara is processing a file.
\end{itemize}

\subsection*{1.0}

\begin{itemize}
\item[\featurenew] First public release.
\end{itemize}

% -------------------------------------------------


\cleardoublepage

% License
% -------------------------------------------------
\section*{License}

\arara is licensed under the 
\href{http://www.opensource.org/licenses/bsd-license.php}{New BSD License}. 
It's important to observe that the New BSD License has been verified as a 
GPL-compatible free software license by the
\href{http://www.fsf.org/}{Free Software Foundation}, and has been vetted as an 
open source license by the 
\href{http://www.opensource.org/}{Open Source Initiative}.

\vfill

\begin{infobox}[skipabove=\baselineskip plus 2pt minus 1pt]
\noindent{\color{araracolor}\fontfamily{fco}\bfseries \arara \ -- the cool \TeX{} 
automation tool}

\vspace{.5em}

\noindent Copyright \copyright{} 2012, Paulo Roberto Massa Cereda

\noindent All rights reserved.

\vspace{1em}

\noindent Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

\begin{itemize}
\item Redistributions of source code must retain the above copyright notice, 
      this list of conditions and the following disclaimer.
\item Redistributions in binary form must reproduce the above copyright notice,
      this list of conditions and the following disclaimer in the documentation 
      and/or other materials provided with the distribution.
\end{itemize}

\vspace{1em}

\noindent\textsc{This software is provided by the copyright holders and 
contributors ``as is'' and any express or implied warranties, including, but not 
limited to, the implied warranties of merchantability and fitness for a 
particular purpose are disclaimed. In no event shall the copyright holder or 
contributors be liable for any direct, indirect, incidental, special, exemplary, 
or consequential damages (including, but not limited to, procurement of 
substitute goods or services; loss of use, data, or profits; or business 
interruption) however caused and on any theory of liability, wheter in contract, 
strict liability, or tort (including negligence or otherwise) arising in any way 
out of the use of this software, even if advised of the possibility of such 
damage.}
\end{infobox}
% -------------------------------------------------

\cleardoublepage

% TOC and list of codes
% -------------------------------------------------
\tableofcontents*

\cleardoublepage

\listofcodes*
% -------------------------------------------------

\mainmatter

% For users
% -------------------------------------------------
\part{For users}
\label{part:users}
% -------------------------------------------------

% Introduction
% -------------------------------------------------
\chapter{Introduction}
\label{chap:intro}

\epigraph{\emph{Pardon me while I fly my aeroplane.}}{From a Monty Python sketch}

Welcome to \arara! I'm glad you were not intimidated by the threatening message 
in the prologue -- What prologue? Anyway, this chapter is a quick introduction to
 what you can expect from \arara. Don't be afraid, it will be easy to digest, I 
promise.

\section{What is \texorpdfstring{\arara}{arara}?}
\label{sec:whatisarara}

Good question. I've been asking it myself for a quite long time. Since I have to 
provide an official definition for \arara -- I'm the author, the one to blame -- 
I'd go with something along these lines:

\begin{quotation}
\noindent\arara is a \TeX{} automation tool. But maybe not in the traditional 
sense, such as existing tools like 
\href{http://www.phys.psu.edu/~collins/latexmk/}{latexmk} and 
\href{https://launchpad.net/rubber/}{rubber}. Think of \arara as a personal 
assistant. It is as powerful as you want it to be. \arara doesn't provide 
solutions out of the box, but it gives you subsidies to enhance your \TeX{} 
experience.
\end{quotation}

Well, that was a shot in the dark. I'm sorry for this crude definition, but the 
truth is: \arara is generic enough to rely on different schemes. \arara will 
execute what you tell it to execute. How will \arara do this? That's the problem: 
you are in control, so it depends on you.

Maybe I should provide an example for a better understanding. Consider the \LaTeX{} 
code presented in Code~\ref{code:hellolatex}. How would you compile 
|mydoc.tex| in |rubber|, for instance? It's quite easy, a simple 
|rubber --pdf mydoc| would do the trick. Now, if you try |arara mydoc|, 
I'm afraid nothing will be generated. Why? Isn't \arara supposed to be a \TeX{} 
automation tool? Well, \arara doesn't know what to do with your file. You need to
tell it. For now, please understand that you need to provide the batteries for 
\arara to run -- bad analogy perhaps, but that's true. Don't worry, we will come 
back to this example later in the manual and see how to make \arara produce the 
desired output.

\begin{code}
\caption{\texttt{mydoc.tex}}
\label{code:hellolatex}
\begin{infobox}[innertopmargin=3pt, innerbottommargin=3pt, 
                innerleftmargin=10pt, innerrightmargin=3pt]
\begin{latex}
\documentclass{article}

\begin{document}

Hello world.

\end{document}
\end{latex}
\end{infobox}
\end{code}

As I keep saying since the first pages of this manual: you are in control of your
 documents. \arara won't do anything unless you teach it how to do a task and 
explicitly tell it to execute the task. Introducing the \arara terminology:

\begin{description}
\item[How can I teach \arara to do a task?] 
        You need to define \arara rules.
\item[How can I tell \arara to execute a task?]
        You need to use \arara directives.
\end{description}

That's probably one of the major differences of \arara from other automation 
tools. With |latexmk| and |rubber|, for example, you have great 
features out of the box, ready for you to use and abuse -- batteries included. 
\arara takes a minimalist approach and gives you the simplicity of doing exactly 
what you want it to do. Nothing more, nothing less.

\section{Features}
\label{sec:features}

There's nothing so special with \arara. It does exactly what you tell it to do. 
On the other hand, one of the features I like in \arara is the ability to write 
rules in a human-readable format. You don't need to rely on other formats. 
Actually, you can write a compiled rule, but I'm almost sure you will never need 
one.

I like to be in control of my \TeX\ documents -- including running commands many 
times my heart desires and in the order I want. I can create a complex workflow 
and \arara will handle it for me -- again, as long as I have the proper rules.

Another feature worth mentioning is the fact that \arara is platform independent. 
I wrote it in Java, so \arara runs on top of a Java Virtual Machine 
(\textsc{jvm}), available on all the major operating systems -- in some cases, 
you might need to install the proper \textsc{jvm}. I tried to keep my code and 
libraries compatible with older virtual machines -- currently, Java 5, 6, 7 and 
OpenJDK 6 are supported. But beware, if you write system-specific rules, you 
will need to adapt them when porting to other operating system.

\section{Common uses}
\label{sec:commonuses}

\arara can be used in complex workflows, like theses and books. You can tell 
\arara to compile the document, generate indices and apply styles, remove 
temporary files, compile other |.tex| documents, run MetaPost or MetaFont, 
create glossaries, call |pdfcrop|, move files, and much more. It's up to 
you.

Code~\ref{code:exlatexone} contains the \arara workflow I used for an article I 
recently wrote. Note that the first call to |pdflatex| creates the 
|.aux| file, then |bibtex| will extract the cited publications. The 
next calls to |pdflatex| will insert and refine the references.

\begin{code}[!ht]
\caption{\texttt{myarticle.tex}}
\label{code:exlatexone}
\begin{infobox}[innertopmargin=3pt, innerbottommargin=3pt, 
                innerleftmargin=10pt, innerrightmargin=3pt]
\begin{latex}
% arara: pdflatex
% arara: bibtex
% arara: pdflatex
% arara: pdflatex
\documentclass[journal]{IEEEtran}
...
\end{latex}
\end{infobox}
\end{code}

Code~\ref{code:exlatextwo} contains another \arara workflow I used for a manual. 
I had to use a package that required shell escape, so the calls to 
|pdflatex| had to enable it. Also, I had an index with a custom formatting, 
then |makeindex| was called with the proper style.

\begin{code}[!ht]
\caption{\texttt{mymanual.tex}}
\label{code:exlatextwo}
\begin{infobox}[innertopmargin=3pt, innerbottommargin=3pt, 
               innerleftmargin=10pt, innerrightmargin=3pt]
\begin{latex}
% arara: pdflatex: { shell: yes }
% arara: makeindex: { style: mystyle }
% arara: pdflatex: { shell: yes }
% arara: pdflatex: { shell: yes }
\documentclass{book}
...
\end{latex}
\end{infobox}
\end{code}

Other workflows can be easily created. There can be an arbitrary number of 
instructions for \arara to execute, so feel free to come up with your own 
workflow. \arara will handle it for you.

I really hope you like my humble contribution to the \TeX\ community. Let \arara 
enhance your \TeX\ experience. Have a good read.

\vspace{2em}

\begin{center}
\color{araracolor}\fontfamily{fco}\bfseries\Large Welcome to arara!
\end{center}

\vfill

\begin{infobox}[frametitle={Trivia}]
Arara is a bird, also known as macaw, native to Mexico, Central America, South 
America, and formerly the Caribbean. Why did I chose this name? Well, araras are 
colorful, noisy, naughty and very funny. Everybody loves araras. So why can't you 
love a tool with the very same name?
\end{infobox}
% -------------------------------------------------

% Installation
% -------------------------------------------------
\chapter{Installation}
\label{chap:installation}

\epigraph{\emph{I would like to buy a hamburger.}}{Inspector Jacques Clouseau, 
The Pink Panther (2006)}

Splendid, so you decided to give \arara a try? This chapter will cover the 
installation procedure. Well, to be honest, there is nothing much to see here. 
The provided |.jar| file is a self-contained, batteries-included executable 
Java file, so it's not an installation per se, but more like a deployment.

\section{Obtaining \texorpdfstring{\arara}{arra}}
\label{sec:obtainingarara}

First of all, we need to obtain the \arara binary. Go to the 
\href{http://github.com/cereda/arara}{project repository} and download the 
current release. The filename to get is |arara.jar|. You can also build 
\arara from sources, but it's far beyond the scope of this manual.

\section{Deployment}
\label{sec:deployment}

The first step is to create an application folder. Feel free to create a folder 
anywhere in your computer. It can be \verb+C:\arara+, \verb+/opt/arara+ or 
another location. My setup is usually \verb+C:\paulo\softwares\arara+ for 
Windows machines and \verb+/opt/paulo/arara+ for Linux and Mac, but this is of 
course a matter of personal taste. For convenience, this folder will be called 
|ARARA_HOME|. Although it's not mandatory, try to avoid folders structures 
with spaces in the path.

Since \arara is written in Java, it requires a Java Virtual Machine. Do you have 
one installed? If you are not sure, try running |java -version| in the 
terminal and see if you get an output similar to the Code~\ref{code:javainstalled}.

\begin{code}[!ht]
\caption{Checking if \texttt{java} is installed.}
\label{code:javainstalled}
\begin{infobox}
\begin{bash}[morekeywords=version]
$ java -version
java version "1.6.0_24"
OpenJDK Runtime Environment (IcedTea6 1.11.1)
OpenJDK Client VM (build 20.0-b12, mixed mode)
\end{bash}
\end{infobox}
\end{code}

If you don't have a proper Java Virtual Machine installed, I suggest you to 
visit the \href{http://www.java.com}{Java website} and download one, according 
to your operating system. Installation instructions are also provided.

Now, copy the |.jar| file we have downloaded in the very first step inside 
the |ARARA_HOME| folder. Don't forget to add |ARARA_HOME| to the 
system path. Unfortunately, this manual can't cover the path settings, since 
it's again a matter of personal taste. For my tools, I usually set the path in 
my local |.bashrc| with |export PATH="$PATH:$ARARA_HOME"|. It's up to 
you.

Instead of adding |ARARA_HOME| to the system path in Linux or Mac, you can
also create a symbolic link for \arara in \verb+/usr/bin/arara+. In this case there's no
need of exporting the application folder. The target for this symbolic link is presented
in the next paragraph.

The last step for deploying \arara is platform-specific. In order to run \arara, 
we should run |java -jar arara.jar|, but that is not intuitive. To make our 
lives easier, we will create a shortcut for this command. If you are in Windows, 
create a file named |arara.cmd| inside |ARARA_HOME| and add the content 
from Code~\ref{code:windows}. If you are in Linux or Mac, create a file named 
|arara| inside |ARARA_HOME| and add the content from
Code~\ref{code:unix}. In Linux and Mac, there only one more thing to do: don't 
forget to add execute permissions for |arara| by running 
|chmod +x arara|. If you want to use a symbolic link, make sure to use \verb|arara| as target.

\begin{code}
\caption{\texttt{arara.cmd} for Windows.}
\label{code:windows}
\begin{infobox}
\begin{bash}
@echo off
java -jar "%~dp0\arara.jar" %*
\end{bash}
\end{infobox}
\end{code}

\begin{code}
\caption{\texttt{arara} for Linux and Mac.}
\label{code:unix}
\begin{infobox}
\begin{bash}
#!/bin/bash
java -jar "$(dirname "$0")/arara.jar" $*
\end{bash}
\end{infobox}
\end{code}

Did you add |ARARA_HOME| to the path? Or did you create a symbolic link to 
\verb+ARARA_HOME/arara+ in a system folder? If so, we are good to go. Try running 
|arara| in the terminal and see if you get the output shown in 
Code~\ref{code:arararun}.

\begin{code}
\caption{Testing if \arara is correctly deployed.}
\label{code:arararun}
\begin{infobox}
\begin{bash}
$ arara
  __ _ _ __ __ _ _ __ __ _ 
 / _` | '__/ _` | '__/ _` |
| (_| | | | (_| | | | (_| |
 \__,_|_|  \__,_|_|  \__,_|

Arara 1.0.1 - The cool TeX automation tool
Copyright (c) 2012, Paulo Roberto Massa Cereda
All rights reserved.

usage: arara [file [--log] [--verbose] | --help | --version]
             
 -h,--help      print the help message
 -l,--log       generate a log output
 -v,--verbose   print the command output
 -V,--version   print the application version
\end{bash}
\end{infobox}
\end{code}

If the terminal doesn't display the \arara logo and usage, please review the 
deployment steps. Every step is important in order to make \arara available in 
your system. If you have any doubts, feel free to contact me.

\section{Updating}
\label{sec:updating}

If there is a newer version of \arara, simply download the |.jar| file and 
move it inside the |ARARA_HOME| folder, replacing the old one. No further 
steps are needed, the newer version is already deployed. Try running 
|arara| in the terminal and see if the version is equal to the one you have 
downloaded.
% -------------------------------------------------

% Getting started
% -------------------------------------------------
\chapter{Getting started}
\label{chap:gettingstarted}

\epigraph{\emph{Is Batman a scientist?}}{Homer Simpson}

Time for our first contact with \arara! It's important to understand two concepts 
in which \arara is based: rules and directives. A \emph{rule} is a formal 
description of how \arara should handle a certain task. For example, if we want 
to use |pdflatex| with \arara, we should have a rule for that. Once a rule 
is defined, \arara automatically provides an access layer to that rule through 
directives. A \emph{directive} is a special comment in the |.tex| file 
which will tell \arara how it should execute a certain task. A directive can have 
as many parameters as its corresponding rule has. Don't worry, let's get started 
with these new concepts.

\section{Rules}
\label{sec:rules}

Do you remember |mydoc.tex| from Code~\ref{code:hellolatex}? When we tried 
to mimic |rubber| and run |arara mydoc|, nothing happened. We should 
tell \arara how it should handle this execution. Let's start with the rules.

A rule is a plain text file written in the \textsc{yaml} format. I chose this 
format because it's cleaner and more intuitive to use than other markup 
languages, besides of course being a data oriented format. As a bonus, 
\textsc{yaml} rhymes with the word \emph{camel}, so \arara is environmentally 
friendly.

The rules must be placed in a special folder inside |ARARA_HOME|. The full 
path for plain \arara rules is |ARARA_HOME/rules/plain|, so feel free to 
create this folder structure before proceeding with the reading. Wait a minute,
what is a plain rule? Easy, it's a rule written using the \textsc{yaml} format. 
We can also have compiled rules in the form of |.jar| files to be placed 
inside |ARARA_HOME/rules/compiled|, but I'm almost sure you will never need 
to write one of them. This manual doesn't cover compiled rules, please refer to 
the developer manual for further reference.

The basic structure of a plain \arara rule is presented in 
Code~\ref{code:yamlrule}.

\begin{code}[!ht]
\caption{\texttt{makefoo.yaml}, a basic structure of a plain \arara rule.}
\label{code:yamlrule}
\begin{infobox}[innertopmargin=3pt, innerbottommargin=3pt,
                innerleftmargin=10pt, innerrightmargin=3pt]
\begin{yaml}
<R>!config<A>
<B>identifier:<A> makefoo
<B>name:<A> MakeFoo
<B>command:<A> makefoo <G>@{<A>file<G>}<A>
<B>arguments:<A> <G>[<A><G>]<A>
\end{yaml}
\end{infobox}
\end{code}

The |!config| keyword (line 1) is mandatory and it must be the first line 
of a plain \arara rule. The following keys are defined:

\begin{description}
\item[identifier]
   This key (line 2) acts as a unique identifier for the rule. It's highly 
   recommended to use lowercase letters without spaces, accents or punctuation 
   symbols. As a convention, if you have an identifier named |makefoo|, the rule 
   filename must be |makefoo.yaml|.
\item[name]
   The |name| key (line 3) holds the name of the task. When running \arara, this 
   value will be displayed in the output. In our example, \arara will display 
   |Running MakeFoo| when dealing with this task.
\item[command] 
   This key (line 4) contains the system command to be executed. It's highly 
   recommended to avoid interactive commands. Prefer those commands that run as 
   a non-interactive mode, mainly because \arara won't output anything in the 
   terminal neither provide user interaction. You probably noticed a strange 
   element |@{file}|: this element is called \emph{orb tag}. For now, just admit 
   they exist. We will come back to them later on, in Section~\ref{sec:orbtags}.
\item[arguments]
   The |arguments| key (line 5) is a list. In our example, it has an empty list, 
   denoted as |[]|. You can define as many arguments as your command requires. 
   Check Code~\ref{code:makebar} for an example of a list of arguments.
\end{description}

For more complex rules, we might want to use arguments. Code~\ref{code:makebar} 
presents a new rule which makes use of them instead of an empty list as we saw 
in Code~\ref{code:yamlrule}.

\begin{code}[!ht]
\caption{\texttt{makebar.yaml}, a rule with arguments.}
\label{code:makebar}
\begin{infobox}[innertopmargin=3pt, innerbottommargin=3pt, 
                innerleftmargin=10pt, innerrightmargin=3pt]
\begin{yaml}
<R>!config<A>
<B>identifier:<A> makebar
<B>name:<A> MakeBar
<B>command:<A> makebar <G>@{<A>one<G>}<A> <G>@{<A>two<G>}<A> <G>@{<A>file<G>}<A>
<B>arguments:<A>
<B>- identifier:<A> one
   <B>flag:<A> -i <G>@{<A>value<G>}<A>
<B>- identifier:<A> two
   <B>flag:<A> -j <G>@{<A>value<G>}<A>
\end{yaml}
\end{infobox}
\end{code}

For every argument in the list, we have a |-| mark and the proper indentation. 
The required keys for an argument are:

\begin{description}
\item[identifier]
     This key (lines 6 and 8) acts as a unique identifier for the argument. It's 
     highly recommended to use lowercase letters without spaces, accents or 
     punctuation symbols.
\item[flag]
     The |flag| key (lines 7 and 9) represents the argument value. Please note 
     that we have another orb tag in the definition, |@{value}|. We will discuss 
     them later in Section~\ref{sec:orbtags}.
\end{description}

For now, just keep in mind that \arara uses rules to tell it how to do a certain 
task. In the next sections, when more concepts are presented, we will come back 
to this subject. Just a taste of things to come: directives are mapped to rules 
through orb tags. Don't worry, I'll explain how things work.

\section{Directives}
\label{sec:directives}

A directive is a special comment inserted in the |.tex| file in which you 
indicate how \arara should behave. You can insert as many directives as you want, 
and in any position of the |.tex| file. \arara will read the whole file and 
extract the directives. A directive should be placed in a line of its own, in 
the form |% arara: <directive>|. There are two types of directives:

\begin{description}
\item[empty directive]  
   An empty directive has only the rule identifier, as we seen in 
   Section~\ref{sec:rules}. Lines 1 and 3 of Code~\ref{code:directiveslatex} 
   show an example of empty directives. Note that you can supress arguments 
   (line 3 in constrast to line 2), but we will see that \arara assumes that you 
   know exactly what you are doing.
\item[parametrized directive]
   A parametrized directive has the rule identifier followed by its arguments. 
   Line 2 of Code~\ref{code:directiveslatex} shows an example of a parametrized 
   directive. Note that the arguments are mapped by their identifiers, not by 
   their positions.
\end{description}

\begin{code}
\caption{Example of directives in a \texttt{.tex} file.}
\label{code:directiveslatex}
\begin{infobox}[innertopmargin=3pt, innerbottommargin=3pt, 
                innerleftmargin=10pt, innerrightmargin=3pt]
\begin{latex}
% arara: makefoo
% arara: makebar: { one: hello, two: bye }
% arara: makebar
\documentclass{article}
...
\end{latex}
\end{infobox}
\end{code}

The arguments are defined according to the rule mapped by the directive. For 
example, the rule |makebar| (Code~\ref{code:makebar}) has a list of two 
arguments, |one| and |two|. So you can safely write 
|makebar: { one: hello }|, but trying to map a nonexisting argument with 
|makebar: { three: hi }| will raise an error.

If you want to disable an \arara directive, there's no need of removing it from 
the |.tex| file. Simply replace |% arara:| by |% !arara:| and this 
directive will be ignored.

Directives are mapped to rules. In Section~\ref{sec:orbtags} we will learn about 
orb tags and then revisit rules and directives. I hope the concepts will be clearer 
since we understand what an orb tag is and how it works.

\section{Orb tags}
\label{sec:orbtags}

When I was planning the mapping scheme, I opted for a templating mechanism. I was 
looking for flexibility, so the \href{http://mvel.codehaus.org}{\textsc{mvel}} 
library was perfect for the job. I could extend my mapping plans by using the 
orb tags. An orb tag consists of a |@| character followed by braces 
|{...}| which contain regular \textsc{mvel} expressions. In particular, 
\arara uses the |@{}| expression orb, which contains a value expression 
which will be evaluated to a string, and appended to the output template. 
For example, the following template |Hello, my name is @{name}| with 
|name| resolving to |Paulo| will be expanded to 
|Hello, my name is Paulo|.

When mapping rules, every command argument will be mapped to the form 
|@{identifier}| with value equals to the content of the |flag| key. 
There are two reserved orb tags, |@{file}| and |@{value}|. The first 
one refers to the |.tex| filename argument passed to \arara. The extension 
is removed, so no matter if \arara is called with |arara mydoc.tex| or 
|arara mydoc|, |@{file}| will be expanded to |mydoc|. The 
|@{file}| value can be overriden, but we will discuss it later. The second 
reserved orb tag |@{value}| is expanded to the argument value passed in the 
directive. If you have |makebar: { one: hello }|, the |flag| key of 
argument |one| will be expanded from the original definition 
|-i @{value}| to |-i hello|. Now |@{one}| contains the expanded 
|flag| value, which is |-i hello|. All arguments tags are expanded in 
the rule command. If one of them is not defined in the directive, \arara will 
admit an empty value, so the |command| flag will be expanded to 
|makebar -i hello mydoc|. The whole procedure is summarized as follows:

\begin{enumerate}
\item \arara processed a file named |mydoc.tex|.
\item A directive |makebar: { one: hello }| was found, so \arara will look 
      up the rule |makebar.yaml| (Code~\ref{code:makebar}).
\item The argument |one| is defined and has value |hello|, so the 
      corresponding |flag| key will have the orb tag |@{value}| 
      expanded to |hello|. The new value is now added to the template 
      referenced by the |command| key and then |@{one}| is expanded to
      |-i hello|.
\item The argument |two| is not defined, so the template referenced by the 
      |command| key has |@{two}| expanded to an empty string.
\item There are no more arguments, so the template referenced by the 
      |command| key now expands |@{file}| to |mydoc|.
\item The final command is now |makebar -i hello mydoc|.
\end{enumerate}

There's a reserved directive key named |files|, which is in fact a list. In 
case you want to override the default |@{file}| value, use the |files| 
key, like |makebar: { files: [ thedoc ] }|. This will result in 
|makebar thedoc| instead of |makebar mydoc|.

If you provide more than one file in the list, \arara will replicate the directive 
for every file found, so  |makebar: { files: [ a, b, c ] }| will result in 
three commands: |makebar a|, |makebar b| and |makebar c|.

\section{Examples}
\label{sec:examples}

Now that we know about rules, directives and orb tags, it's time to come up with 
some examples. I know it's not trivial to understand how \arara works, but I'm 
sure the examples will help with the concepts. Please note that there might have 
platform-specific rules, so double-check the commands before running them.

\subsection{PDFLaTeX}
\label{sub:pdflatex}

Our first example is to add support to |pdflatex|. My first attempt to 
write this rule is presented in Code~\ref{code:pdflatexone}.

\begin{code}[!ht]
\caption{\texttt{pdflatex.yaml}, first attempt.}
\label{code:pdflatexone}
\begin{infobox}[innertopmargin=3pt, innerbottommargin=3pt, 
                innerleftmargin=10pt, innerrightmargin=3pt]
\begin{yaml}
<R>!config<A>
<B>identifier:<A> pdflatex
<B>name:<A> PDFLaTeX
<B>command:<A> pdflatex -interaction=nonstopmode <G>@{<A>file<G>}<A>.tex
<B>arguments:<A> <G>[<A><G>]<A>
\end{yaml}
\end{infobox}
\end{code}

So far, so good. The |command| flag has the |pdflatex| program and also
 the flag |-interaction=nonstopmode|, since \arara doesn't provide user 
interaction. Now we can add the |pdflatex| directive to our |.tex| 
file, as we can see in Code~\ref{code:helloexampleone}.

\begin{code}[!ht]
\caption{\texttt{helloworld.tex}}
\label{code:helloexampleone}
\begin{infobox}[innertopmargin=3pt, innerbottommargin=3pt, 
                innerleftmargin=10pt, innerrightmargin=3pt]
\begin{latex}
% arara: pdflatex
\documentclass{article}

\begin{document}

Hello world.

\end{document}
\end{latex}
\end{infobox}
\end{code}

It's just a matter of calling |arara helloworld.tex| ( you can also provide 
the |.tex| extension by calling |arara helloworld.tex|) and \arara will 
process our file, according to the Code~\ref{code:araraoutputone}.

\begin{code}[!ht]
\caption{\protect\arara output for \texttt{pdflatex}.}
\label{code:araraoutputone}
\begin{infobox}
\begin{bash}
$ arara helloworld
  __ _ _ __ __ _ _ __ __ _
 / _` | '__/ _` | '__/ _` |
| (_| | | | (_| | | | (_| |
 \__,_|_|  \__,_|_|  \__,_|

Running PDFLaTeX... SUCCESS
\end{bash}
\end{infobox}
\end{code}

Great, our first rule works like a charm. Once we define a rule, the directive is
automatically available for us to call it as many times as we want. What if we 
make this rule better? Consider the following situation:

\begin{quotation}
\noindent Sometimes, we need to use |\write18| or call a package that makes 
use of it (for example, |minted|). It's very dangerous to enable shell 
escape globally, but changing the |pdflatex| call every time we need it 
sounds boring.
\end{quotation}

\arara has a special treatment for cases like this. In the early stages of 
development, \arara was able to handle boolean values. Entries with |true| 
or |false|, |on| or |off|, |yes| and |no| were mapped 
to boolean values. If you wanted to use |yes| as text, you could explicitly 
tell \arara that the value was a string by enclosing it with single or double 
quotes, |'yes'| or |"yes"|. In my humble opinion, it was a good design 
at first, but it opened a dangerous pitfall: if a certain mapping was expecting 
a boolean, but another value was received, the result was automatically resolved 
to |true|. We have enough problems of \arara itself giving us enough rope, 
so I decided to consider every argument value as string. No big deal, we can 
still mimic a boolean behaviour, as we will see in our next attempt.

We will rewrite our |pdflatex| rule to include a flag for shell escape. 
Another cool feature will be presented now, as we can see in the new rule shown 
in Code~\ref{code:pdflatextwo}.

\begin{code}[!ht]
\caption{\texttt{pdflatex.yaml}, second attempt.}
\label{code:pdflatextwo}
\begin{infobox}[innertopmargin=3pt, innerbottommargin=3pt, 
                innerleftmargin=10pt, innerrightmargin=3pt]
\begin{yaml}
<R>!config<A>
<B>identifier:<A> pdflatex
<B>name:<A> PDFLaTeX
<B>command:<A> pdflatex -interaction=nonstopmode <G>@{<A>shell<G>}<A> <G>@{<A>file<G>}<A>.tex
<B>arguments:<A>
<B>- identifier:<A> shell
   <B>flag:<A> '<G>@{<A>value == "yes" ? "-shell-escape" : "-no-shell-escape" <G>}<A>'
\end{yaml}
\end{infobox}
\end{code}

Orb tags allow evaluation inside the tag block! Line 7 from 
Code~\ref{code:pdflatextwo} makes use of the ternary operator |?:| 
which defines a conditional expression. In the first part of the evaluation, 
we check if |value| is equal to the string |"yes"|. If so, 
|"-shell-escape"| is defined as the result of the operation. If the 
conditional expression is false, |"-no-shell-escape"| is set instead.

What if you want to allow |true| and |on| as valid options as well? We 
can easily rewrite our orb tag to check for additional values. It's also 
possible to invoke some string methods on orb tags, like |toLowerCase|. A 
third attempt is presented in Code~\ref{code:pdflatexthree}. The 
|toLowerCase| method was added to allow entries like |Yes|, |yEs| 
and other combinations. Although \arara can support cases in arguments and values, 
I recommend you to stick with lowercase entries. By the way, for more complex 
orb tag schemes, it's important to enclose the orb tags with either single or 
double quotes. Of course, if you use single quotes to enclose the orb tags, use 
double quotes for internal evaluations, and vice versa.

\begin{code}[!ht]
\caption{\texttt{pdflatex.yaml}, third attempt.}
\label{code:pdflatexthree}
\begin{infobox}[innertopmargin=3pt, innerbottommargin=3pt, 
                innerleftmargin=10pt, innerrightmargin=3pt]
\begin{yaml}
<R>!config<A>
<B>identifier:<A> pdflatex
<B>name:<A> PDFLaTeX
<B>command:<A> pdflatex -interaction=nonstopmode <G>@{<A>shell<G>}<A> <G>@{<A>file<G>}<A>.tex
<B>arguments:<A>
<B>- identifier:<A> shell
   <B>flag:<A> '<G>@{<A>value.toLowerCase() == "yes" || value.toLowerCase() == "true" || value.toLowerCase() == "on" ? "-shell-escape" : "-no-shell-escape" <G>}<A>'
\end{yaml}
\end{infobox}
\end{code}

With this new rule, it's now easy to enable the shell escape option in 
|pdflatex|. Simply go with the directive |pdflatex: { shell: yes }|. 
You can also use |true| or |on| instead of |yes|. Any other value 
for |shell| will disable the shell escape option. It's important to observe 
that \arara directives have no mandatory arguments. If you want to add a dangerous 
option like |-shell-escape|, consider calling it as an argument with a 
proper check and rely on a safe state for the argument fallback.

\subsection{MakeIndex}
\label{sub:makeindex}

For the next example, we will create a rule for |makeindex|. To be honest, 
although |makeindex| has a lot of possible arguments, I only use the 
|-s| flag once in a while. Code~\ref{code:makeindexone} shows our first 
attempt of writing this rule.

\begin{code}[!ht]
\caption{\texttt{makeindex.yaml}, first attempt.}
\label{code:makeindexone}
\begin{infobox}[innertopmargin=3pt, innerbottommargin=3pt, 
                innerleftmargin=10pt, innerrightmargin=3pt]
\begin{yaml}
<R>!config<A>
<B>identifier:<A> makeindex
<B>name:<A> MakeIndex
<B>command:<A> makeindex <G>@{<A>style<G>}<A> <G>@{<A>file<G>}<A>.idx
<B>arguments:<A>
<B>- identifier:<A> style
   <B>flag:<A> -s <G>@{<A>value<G>}<A>
\end{yaml}
\end{infobox}
\end{code}

As a follow-up to our fist attempt, we will now add support for the |-g| 
flag that employs German word ordering in the index. Since this flag is 
basically a switch, we can borrow the same tactic used for shell escape in the 
previous example. The new rule is presented in Code~\ref{code:makeindextwo}.

\begin{code}[!ht]
\caption{\texttt{makeindex.yaml}, second attempt.}
\label{code:makeindextwo}
\begin{infobox}[innertopmargin=3pt, innerbottommargin=3pt, 
                innerleftmargin=10pt, innerrightmargin=3pt]
\begin{yaml}
<R>!config<A>
<B>identifier:<A> makeindex
<B>name:<A> MakeIndex
<B>command:<A> makeindex <G>@{<A>german<G>}<A> <G>@{<A>style<G>}<A> <G>@{<A>file<G>}<A>.idx
<B>arguments:<A>
<B>- identifier:<A> style
   <B>flag:<A> -s <G>@{<A>value<G>}<A>
<B>- identifier:<A> german
   <B>flag:<A> '<G>@{<A>value.toLowerCase() == "yes" || value.toLowerCase() == "true" || value.toLowerCase() == "on" ? "-g" : "" <G>}<A>'
\end{yaml}
\end{infobox}
\end{code}

The new |makeindex| rule presented in Code~\ref{code:makeindextwo} looks 
good. We can now test the compilation workflow with an example. Consider a file 
named |helloindex.tex| which has a few index entries, presented in 
Code~\ref{code:examplemakeindex}. As usual, I'll present my normal workflow, 
that involves calling |pdflatex| two times to get references right, one
call to |makeindex| and finally, a last call to |pdflatex|. Though 
there's no need of calling |pdflatex| two times in the beginning, I'll keep 
that as a good practice from my side.

\begin{code}[!ht]
\caption{\texttt{helloindex.tex}}
\label{code:examplemakeindex}
\begin{infobox}[innertopmargin=3pt, innerbottommargin=3pt, 
                innerleftmargin=10pt, innerrightmargin=3pt]
\begin{latex}
% arara: pdflatex
% arara: pdflatex
% arara: makeindex
% arara: pdflatex
\documentclass{article}

\usepackage{makeidx}

\makeindex

\begin{document}

Hello world\index{Hello world}.

Goodbye world\index{Goodbye world}.

\printindex

\end{document}
\end{latex}
\end{infobox}
\end{code}

By running |arara helloindex| or |helloindex.tex| in the terminal, we 
will obtain the same output from Code~\ref{code:araramakeexample}. The execution 
order is defined by the directives order in the |.tex| file. If any command 
fails, \arara halts at that position and nothing else is executed.

You might ask how \arara knows if the command was successfully executed. The idea 
is quite simple: good programs like |pdflatex| make use of a concept known 
as exit status. In short, when a program had a normal execution, the exit status 
is zero. Other values are returned when an abnormal execution happened. When 
|pdflatex| successfully compiles a |.tex| file, it returns zero, so 
\arara intercepts this number. Again, it's a good practice to make command line 
applications return proper exit status according to the execution flow, but 
beware: you might find applications or shell commands that don't feature this 
control (in the worst case, the returned value is always zero).

\begin{code}[!ht]
\caption{Running \texttt{helloindex.tex}.}
\label{code:araramakeexample}
\begin{infobox}
\begin{bash}
$ arara helloindex
  __ _ _ __ __ _ _ __ __ _
 / _` | '__/ _` | '__/ _` |
| (_| | | | (_| | | | (_| |
 \__,_|_|  \__,_|_|  \__,_|

Running PDFLaTeX... SUCCESS
Running PDFLaTeX... SUCCESS
Running MakeIndex... SUCCESS
Running PDFLaTeX... SUCCESS
\end{bash}
\end{infobox}
\end{code}

According to the terminal output shown in Code~\ref{code:araramakeexample}, 
\arara executed all the commands successfully. In Chapter~\ref{chap:logging} 
we will learn more about how \arara deals with commands and how to get their 
outputs for a more detailed analysis.

\subsection{Cleaning temporary files}
\label{sub:clean}

After running |arara helloindex| successfully 
(Code~\ref{code:araramakeexample}), we now have as a result a new 
|helloindex.pdf| file, but also a lot of auxiliary files, as we can see in
Code~\ref{code:lsone}.

\begin{code}[!ht]
\caption{List of auxiliary files after running \texttt{arara helloindex}.}
\label{code:lsone}
\begin{infobox}
\begin{bash}
$ ls
helloindex.aux  helloindex.ilg  helloindex.log  helloindex.tex
helloindex.idx  helloindex.ind  helloindex.pdf
\end{bash}
\end{infobox}
\end{code}

What if we write a new |clean| rule to remove all the auxiliary files? The 
idea is to use |rm| to remove each one of them. As mentioned in the 
beginning of the manual, some rules might be system-specific, so this one is a 
perfect example.

Since we want our rule to be generic enough, it's now a good opportunity to 
introduce the use of the reserved directive key |files|, first seen in 
Section~\ref{sec:orbtags}. This special key is a list that overrides the default 
|@{file}| value and replicates the directive for every element in the list. 
I'm sure this will be the easiest rule we've written so far. The |clean| 
rule is presented in Code~\ref{code:cleanone}.

\begin{code}[!ht]
\caption{\texttt{clean.yaml}}
\label{code:cleanone}
\begin{infobox}[innertopmargin=3pt, innerbottommargin=3pt, 
               innerleftmargin=10pt, innerrightmargin=3pt]
\begin{yaml}
<R>!config<A>
<B>identifier:<A> clean
<B>name:<A> CleaningTool
<B>command:<A> rm -f <G>@{<A>file<G>}<A>
<B>arguments:<A> <G>[<A><G>]<A>
\end{yaml}
\end{infobox}
\end{code}

Note that the command |rm| has a |-f| flag. As mentioned before, 
commands return an exit status after their calls. If we try to remove a 
nonexistent file, |rm| will complain and return a value different than zero. 
This will make \arara halt and print a big \textsc{failure}  on screen, since it 
is considered an abnormal execution. If we provide the |-f| flag, |rm| 
will not complain of a nonexistent file, so we won't be bothered for this 
trivial task.

Now we need to add the directive to our |helloindex.tex| file 
(Code~\ref{code:examplemakeindex}). Of course, |clean| will be the last 
directive, since it will only be reachable if everything executed before was 
returned no errors. The new header of |helloindex.tex| is presented in 
Code~\ref{code:examplemakeindextwo}.

\begin{code}[!ht]
\caption{\texttt{helloindex.tex} with the new \texttt{clean} directive.}
\label{code:examplemakeindextwo}
\begin{infobox}[innertopmargin=3pt, innerbottommargin=3pt, 
                innerleftmargin=10pt, innerrightmargin=3pt]
\begin{latex}
% arara: pdflatex
% arara: pdflatex
% arara: makeindex
% arara: pdflatex
% arara: clean: { files: [ helloindex.aux, helloindex.idx, helloindex.ilg, helloindex.ind, helloindex.log ] }
\documentclass{article}
...
\end{latex}
\end{infobox}
\end{code}

The reserved directive key |files| has five elements, so the |clean| 
rule will be replicated five times with the orb tag |@{file}| being 
expanded to each element. If you wish, you can also evaluate the value through 
conditional expression, as we did before with the other rules. In my opinion, I 
don't think it's necessary for this particular rule.

Time to run |arara helloindex| again and see if our new |clean| rule 
works! Code~\ref{code:araramakeexampletwo} shows both \arara execution and 
directory listing. We expect to find only our source |helloindex.tex| and 
the resulting |helloindex.pdf| file.

\begin{code}[!ht]
\caption{Running \texttt{helloindex.tex} with the new \texttt{clean} rule.}
\label{code:araramakeexampletwo}
\begin{infobox}
\begin{bash}
$ arara helloindex
  __ _ _ __ __ _ _ __ __ _ 
 / _` | '__/ _` | '__/ _` |
| (_| | | | (_| | | | (_| |
 \__,_|_|  \__,_|_|  \__,_|

Running PDFLaTeX... SUCCESS
Running PDFLaTeX... SUCCESS
Running MakeIndex... SUCCESS
Running PDFLaTeX... SUCCESS
Running CleaningTool... SUCCESS
Running CleaningTool... SUCCESS
Running CleaningTool... SUCCESS
Running CleaningTool... SUCCESS
Running CleaningTool... SUCCESS
$ ls
helloindex.pdf  helloindex.tex
\end{bash}
\end{infobox}
\end{code}

Great, the |clean| rule works like a charm! A friendly note: if you are in 
Windows, replacing |rm| by the equivalent |del| won't probably work. 
Commands like |del| must be called in the form |cmd /c del|. Make sure 
to exhaustively test your rules before putting them into production. Check 
Chapter~\ref{chap:logging} to learn more about tracking the \arara execution.
% -------------------------------------------------

% When something goes on
% -------------------------------------------------
\chapter{When something goes wrong}
\label{chap:logging}

\epigraph{\emph{Don't panic!}}{From The Hitchhiker's\\ Guide to the Galaxy}

One of \arara's goals is to reduce the verbosity of commands. Though the 
extensive output might contain relevant information about the execution process, 
in most of the cases it is simply to much stuff going on for us to follow. 
Besides, commands like |pdflatex| generate a proper |.log| file for us 
to check how things went. \arara's minimalist approach informs us about the 
execution status: \textsc{success} or \textsc{failure}. When things go terribly 
wrong, we need to rely on more than this status. We should ask \arara to keep 
track of the execution plan for us.

\section{\texorpdfstring{\arara}{arra} messages}
\label{sec:araramessages}

\arara messages are the first type of feedback provided by \arara. These messages 
are basically related to rules and directives. Bad syntax, nonexisting rules, 
malformed directives, wrong expansion, \arara tries to tell you what went wrong. 
Those messages are usually associated with errors. I tried to include useful 
messages, like telling in which directive and line an error ocurred, or that a 
certain rule does not exist or has an incorrect format. \arara also checks if a 
command is valid. If you try to call a rule that executes a nonexisting 
|makefoo| command, \arara will complain about it.

\section{Logging}
\label{sec:logging}

Another way of looking for an abnormal behaviour is to read the proper 
|.log| file. Unfortunately, not every command emits a report of its 
execution and, even if the command generates a |.log| file, multiple runs 
would overwrite the previous reports and we would have only the last call. 
\arara provides a more consistent way of monitoring commands and their own 
behaviour through a global |.log| file that holds every single bit of 
information. You can enable the logging feature by adding either the 
|--log| or |-l| flags to the |arara| application.

Before we continue, I need to explain about standard streams, since they 
constitute an important part of the generated |.log| file by \arara. 
\href{http://en.wikipedia.org/wiki/Standard_streams}{Wikipedia} has a nice 
definition of them:

\begin{quotation}
\noindent ``In computer programming, standard streams are preconnected input and 
output channels between a computer program and its environment (typically a text 
terminal) when it begins execution. The three \textsc{i/o} connections are called 
standard input (|stdin|), standard output (|stdout|) and standard error
(|stderr|).''
\end{quotation}

Basically, the operating system provides two streams directed to display data: 
|stdout| and |stderr|. Usually, the first stream is used by a program 
to write its output data, while the second one is typically used to output error 
messages or diagnostics. Of course, the decision of what output stream to use is 
up to the program author.

When \arara traces a command execution, it logs both |stdout| and 
|stderr|. The log entry for |stdout| is \texttt{Standard output 
logging} while |stderr| is referenced by \texttt{Standard error logging}. 
Again, an output to |stderr| does not necessarily mean that an error was 
found in the code, while an output to |stdout| does not necessarily mean 
that everything ran flawlessly. It's just a naming convention, as the program 
author decides how to handle the messages flow. That's why \arara logs them both. 
Read the |stdout| and |stderr| log entries carefully. A excerpt of the 
resulting |arara.log| from |arara helloindex --log| is show in 
Code~\ref{code:araralog} -- several lines were removed in order to leave only 
the more important parts.

The \arara log is useful for keeping track of the execution flow as well as 
providing feedback on how both rules and directives are being expanded. The log 
file contains information about the directive extraction and parsing, rules 
checking and expansion, deployment of tasks and execution of commands. The \arara 
messages are also logged.

\begin{code}[p!]
\caption{\texttt{arara.log} from \texttt{arara helloindex {-}{-}log}.}
\label{code:araralog}
\begin{infobox}
\begin{lstlisting}[basicstyle=\footnotesize\ttfamily, columns=flexible, showspaces=false, breaklines=true]
09 Abr 2012 11:27:58.400 INFO  Arara - Welcome to Arara!
09 Abr 2012 11:27:58.406 INFO  Arara - Processing file helloindex.tex, please wait.
09 Abr 2012 11:27:58.413 INFO  DirectiveExtractor - Reading directives from helloindex.tex.
09 Abr 2012 11:27:58.413 TRACE DirectiveExtractor - Directive found in line 1 with pdflatex.
...
09 Abr 2012 11:27:58.509 INFO  DirectiveParser - Parsing directives.
09 Abr 2012 11:27:58.536 INFO  TaskDeployer - Deploying tasks into commands.
09 Abr 2012 11:27:58.703 INFO  CommandTrigger - Ready to run commands.
09 Abr 2012 11:27:58.704 INFO  CommandTrigger - Running PDFLaTeX.
09 Abr 2012 11:27:58.704 TRACE CommandTrigger - Command: pdflatex -interaction=nonstopmode  helloindex.tex
09 Abr 2012 11:27:59.435 TRACE CommandTrigger - Standard error logging: 
09 Abr 2012 11:27:59.435 TRACE CommandTrigger - Standard output logging: This is pdfTeX, Version 3.1415926-2.3-1.40.12 (TeX Live 2011)
...
Output written on helloindex.pdf (1 page, 12587 bytes).
Transcript written on helloindex.log.
09 Abr 2012 11:27:59.435 INFO  CommandTrigger - PDFLaTeX was successfully executed.
09 Abr 2012 11:27:59.655 INFO  CommandTrigger - Running MakeIndex.
09 Abr 2012 11:27:59.655 TRACE CommandTrigger - Command: makeindex   helloindex.idx
09 Abr 2012 11:27:59.807 TRACE CommandTrigger - Standard error logging: This is makeindex, version 2.15 [TeX Live 2011] (kpathsea + Thai support).
...
Generating output file helloindex.ind..done (9 lines written, 0 warnings).
Output written in helloindex.ind.
Transcript written in helloindex.ilg.
09 Abr 2012 11:27:59.807 TRACE CommandTrigger - Standard output logging: 
09 Abr 2012 11:27:59.807 INFO  CommandTrigger - MakeIndex was successfully executed.
...
09 Abr 2012 11:28:00.132 INFO  CommandTrigger - All commands were successfully executed.
09 Abr 2012 11:28:00.132 INFO  Arara - Done.
\end{lstlisting}
\end{infobox}
\end{code}

If by any chance your code is not working, try to run |arara| with the 
logging feature enabled. It might take a while for you to digest the log entries, 
but I'm sure you will be able to track every single step of \arara's execution and 
fix the offending line in your code.
% -------------------------------------------------

% Best practices
% -------------------------------------------------
\chapter{Best practices}
\label{chap:bestpractices}

\epigraph{\emph{Snakes! Why did it have to be snakes?}}{Indiana Jones,\\ Raiders 
of the Lost Ark (1981)}

The following list contains some hints on best practices when using \arara. I 
tried my best to name a few situations and annoyances that you might encounter, 
but the list is far from being complete and accurate. Feel free to establish your 
own practices. After all, \arara depends on the user, and not the other way around.

\section{Plain rules}
\label{sec:plainrules}

\begin{description}
\item[Use a text editor with support to {\normalfont\texttt{.yaml}} files]
              In my humble opinion, \textsc{yaml} is a great format for 
              expressing \arara rules, but you might encounter problems if the 
              |.yaml| file is not well-formed. Please follow the rule format 
              presented in Section~\ref{sec:rules} and use a text editor with 
              proper support to the \textsc{yaml} format. Personally, I use 
              \href{http://www.vim.org}{Vim} for editing \arara rules.
\item[Use only lowercase letters when defining identifiers for rules]
              Avoid at all costs uppercase letters, digits, spaces, punctuation 
              or other symbols when defining the |identifier| key for 
              \arara rules.
\item[Prefer to enclose orb tags with single quotes]
              Although you can also enclose orb tags with double quotes, I 
              suggest you to stick with single quotes. Use double quotes inside 
              the orb tag for possible evaluations.
\item[If the key value only contains an orb tag, enclose it]
              Compare the |flag| key of the two arguments from the 
              |makeindex| rule (Code~\ref{code:makeindextwo}). When there's 
              only the orb tag as value or if the orb tag comes first in the 
              value, please enclose the whole value with single quotes, like 
              |'@{value}'| or |'@{value} --flag'|. \arara tries to 
              resolve the value type, but sometimes orb tags can mislead the 
              extractor. If you want to play it safe, enclose the value with 
              single quotes.
\item[Don't use reserved keywords as identifiers]
              \arara has a few reserved keywords: |file|, |files|,
              |value| and |arara|. Don't use them as identifiers, 
              otherwise name clashes will make \arara's behaviour unpredictable 
              and mess with the document workflow.
\end{description}

\section{Directives}
\label{sec:directives}

\begin{description}
\item[If an argument value has spaces, enclose it with quotes]
              Again, try to avoid at all costs values with spaces, but if you 
              really need them, enclose the value with single quotes. Beware: 
              commands might require you to enclose values with spaces with 
              double quotes! If you try to run the directive 
              |clean: { files: [ 'my doc.aux' ] }|, the command will be 
              expanded to |rm -f my doc.aux| which is wrong! Two files will 
              be removed: |my| and |doc.aux|. The solution is to use 
              double quotes inside the value surround by single quotes, so a 
              call to the directive |clean: { files: [ '"my doc.aux"' ] }| 
              will be expanded to |rm -f "my doc.aux"| which is correct. 
              Another example is the |makeindex| directive. If you have a 
              style named |my style.ist|, you can call it by running 
              |makeindex: { style: '"my style"' }| and the command will be
              correctly expanded.
\end{description}

\vfill

\begin{infobox}%[frametitle={}]
If you want to make sure that both rules and directives are being mapped and 
expanded correctly, enable the logging option with the |--log| flag and 
verify the output. All expansions are logged.
\end{infobox}
% -------------------------------------------------

% Predefined rules
% -------------------------------------------------
\chapter{Predefined rules}
\label{chap:predefinedrules}

On the next pages you will find some predefined styles which can be used out
of the box. 

However it's important to save the rules in the folder |ARARA_HOME/rules/plain|
(see section \ref{sec:rules}). 


The description of the optional arguments contains the flag argument |yes|. 
Please note you can also use |on| or |true| in capitals or not. That means values 
like |TrUe| or |YES| are also welcome.

If you have some improvements or new rules please inform me.

The rules |latex|, |pdflatex|, |xelatex| and |lualatex| provide the option
|write18|. This option doesn't work out of the box because the \emph{orb tag} 
isn't set in the command line. If you use MikTeX you have to change the 
\emph{orb tag} of the command line from |@{shell}| to |@{write18}| to work
with the optional argument |write18|. This behavior depends on the facht that
the rules were written for using with TeX Live.


\begin{yamlrule}
\headyamlrule{latex}
 The rule calls the compiler |latex|. The rule doesn't have a mandatory argument. 
 Inside your |.tex| file you can use:
\begin{latex}
% arara: latex
\end{latex}
\optionyamlrule
\renewcommand\arraystretch{1.3}
\noindent\begin{tabular}{>{\mbox{}\ttfamily\color{bluekeywords}}p{3cm}p{8cm}}
 action         & The flag \mbox{\ttfamily\color{bluekeywords}action} will be passed 
                 the argument to the compilation option |interaction|. By default the rule will use
                 |--interaction=nonstopmode|.                       \\
 shell         & If you say |shell:yes| you compile with |--shell-escape| 
                 otherwise with |--no-shell-escape|                           \\
 write18       & If you say |write:yes| you compile with |--enable-write18|
                 otherwise with |--disable-write18|                           \\
 synctex       & If you say |synctex:yes| you compile with |--synctex=1| 
                 otherwise with |--synctex=0|                                 \\
 draft         & If you say |draft:yes| you compile with |-draftmode| otherwise
                 with |--draftmode=off|                                       \\
 expandoptions & Every value of this options will be passed to the compilation 
                 run direct. So you can expand the option list.               \\
\end{tabular}
\end{yamlrule}
%------------------------------------------------------------------------------
\begin{yamlrule}
\headyamlrule{pdflatex}
 The rule calls the compiler |pdflatex|. The rule doesn't have a mandatory argument. 
 Inside your |.tex| file you can use:
\begin{latex}
% arara: pdflatex
\end{latex}
\optionyamlrule
\renewcommand\arraystretch{1.3}
\noindent\begin{tabular}{>{\mbox{}\ttfamily\color{bluekeywords}}p{3cm}p{8cm}}
 action         & The flag \mbox{\ttfamily\color{bluekeywords}action} will be passed 
                 the argument to the compilation option |interaction|. By default the rule will use
                 |--interaction=nonstopmode|.                       \\
 shell         & If you say |shell:yes| you compile with |--shell-escape| 
                 otherwise with |--no-shell-escape|                           \\
 write18       & If you say |write:yes| you compile with |--enable-write18|
                 otherwise with |--disable-write18|                           \\
 synctex       & If you say |synctex:yes| you compile with |--synctex=1| 
                 otherwise with |--synctex=0|                                 \\
 draft         & If you say |draft:yes| you compile with |-draftmode| otherwise
                 with |--draftmode=off|                                       \\
 expandoptions & Every value of this options will be passed to the compilation 
                 run direct. So you can expand the option list.               \\
\end{tabular}
\end{yamlrule}
%------------------------------------------------------------------------------
\begin{yamlrule}
\headyamlrule{lualatex}
 The rule calls the compiler |lualatex|. The rule doesn't have a mandatory argument. 
 Inside your |.tex| file you can use:
\begin{latex}
% arara: lualatex
\end{latex}
\optionyamlrule
\renewcommand\arraystretch{1.3}
\noindent\begin{tabular}{>{\mbox{}\ttfamily\color{bluekeywords}}p{3cm}p{8cm}}
 action         & The flag \mbox{\ttfamily\color{bluekeywords}action} will be passed 
                 the argument to the compilation option |interaction|. By default the rule will use
                 |--interaction=nonstopmode|.                       \\
 shell         & If you say |shell:yes| you compile with |--shell-escape| 
                 otherwise with |--no-shell-escape|                           \\
 write18       & If you say |write:yes| you compile with |--enable-write18|
                 otherwise with |--disable-write18|                           \\
 synctex       & If you say |synctex:yes| you compile with |--synctex=1| 
                 otherwise with |--synctex=0|                                 \\
 draft         & If you say |draft:yes| you compile with |-draftmode| otherwise
                 with |--draftmode=off|                                       \\
 expandoptions & Every value of this options will be passed to the compilation 
                 run direct. So you can expand the option list.               \\
\end{tabular}
\end{yamlrule}
%------------------------------------------------------------------------------
\begin{yamlrule}
\headyamlrule{xelatex}
 The rule calls the compiler |xelatex|. The rule doesn't have a mandatory argument. 
 Inside your |.tex| file you can use:
\begin{latex}
% arara: xelatex
\end{latex}
\optionyamlrule
\renewcommand\arraystretch{1.3}
\noindent\begin{tabular}{>{\mbox{}\ttfamily\color{bluekeywords}}p{3cm}p{8cm}}
 action         & The flag \mbox{\ttfamily\color{bluekeywords}action} will be passed 
                 the argument to the compilation option |interaction|. By default the rule will use
                 |--interaction=nonstopmode|.                       \\
 shell         & If you say |shell:yes| you compile with |--shell-escape| 
                 otherwise with |--no-shell-escape|                           \\
 write18       & If you say |write:yes| you compile with |--enable-write18|
                 otherwise with |--disable-write18|                           \\
 synctex       & If you say |synctex:yes| you compile with |--synctex=1| 
                 otherwise with |--synctex=0|                                 \\
 expandoptions & Every value of this options will be passed to the compilation 
                 run direct. So you can expand the option list.               \\
\end{tabular}
\end{yamlrule}
%------------------------------------------------------------------------------
\begin{yamlrule}
\headyamlrule{biber}
 The rule calls the bibliography compiler |biber|. The compiler is recommended
 by |biblatex| and so implemented by \arara. The rule doesn't have a mandatory
 argument. Inside your |.tex| file you can use:
\begin{latex}
% arara: biber
\end{latex}
\optionyamlrule
\renewcommand\arraystretch{1.3}
\noindent\begin{tabular}{>{\mbox{}\ttfamily\color{bluekeywords}}p{3cm}p{8cm}}
 expandoptions & Every value of this options will be passed to the compilation 
                 run direct. So you can expand the option list.               \\
\end{tabular}
\end{yamlrule}
%------------------------------------------------------------------------------
\begin{yamlrule}
\headyamlrule{bibtex}
 The rule calls the standard bibliography compiler |bibtex|. The rule doesn't 
 have a mandatory argument. Inside your |.tex| file you can use:
\begin{latex}
% arara: biber
\end{latex}
\optionyamlrule
\renewcommand\arraystretch{1.3}
\noindent\begin{tabular}{>{\mbox{}\ttfamily\color{bluekeywords}}p{3cm}p{8cm}}
 expandoptions & Every value of this options will be passed to the compilation 
                 run direct. So you can expand the option list.               \\
\end{tabular}
\end{yamlrule}
%------------------------------------------------------------------------------
\begin{yamlrule}
\headyamlrule{makeglossaries}
 The rule calls the perl script |makeglossaries| provided by the package 
 |glossaries| The rule doesn't have a mandatory argument. Inside your |.tex|
 file you can use:
\begin{latex}
% arara: makeglossaries
\end{latex}
\optionyamlrule
\renewcommand\arraystretch{1.3}
\noindent\begin{tabular}{>{\mbox{}\ttfamily\color{bluekeywords}}p{3cm}p{8cm}}
 expandoptions & Every value of this options will be passed to the compilation 
                 run direct. So you can expand the option list.               \\
\end{tabular}
\end{yamlrule}
%------------------------------------------------------------------------------
\begin{yamlrule}
\headyamlrule{makeindex}
 The rule calls the standard index processor of \LaTeX. The rule doesn't have 
 a mandatory argument. Inside your |.tex| file you can use:
\begin{latex}
% arara: makeindex
\end{latex}
\optionyamlrule
\renewcommand\arraystretch{1.3}
\noindent\begin{tabular}{>{\mbox{}\ttfamily\color{bluekeywords}}p{3cm}p{8cm}}
 style         & You can specify a style file which will be used by |makeindex|.\\
 expandoptions & Every value of this options will be passed to the compilation 
                 run direct. So you can expand the option list.               \\              
\end{tabular}
\end{yamlrule}
%------------------------------------------------------------------------------
\begin{yamlrule}
\headyamlrule{nomencl}
 The rule calls the correct |makeindex| run which is required by the package
 |nomencl|. The rule doesn't have a mandatory argument. Inside your |.tex| file
 you can use:
\begin{latex}
% arara: nomencl
\end{latex}
\optionyamlrule
\renewcommand\arraystretch{1.3}
\noindent\begin{tabular}{>{\mbox{}\ttfamily\color{bluekeywords}}p{3cm}p{8cm}}
 log           & If you say |log:yes| the compilation by |makeindex| will create
                 a log file named |mynomencl.nlg|                            \\

 stylefile     & If you want to use your own style file for the compilation by
                 |makeindex| you can give the name of the file as argument to the
                 option.                                                      \\
 expandoptions & Every value of this options will be passed to the compilation 
                 run direct. So you can expand the option list.               \\          
\end{tabular}
\end{yamlrule}

%------------------------------------------------------------------------------
\begin{yamlrule}
\headyamlrule{make}
 The rule calls the Unix command |make|. The argument of make can be handled as
 mandatory because it depends on you |Makefile|. 
\begin{latex}
% arara: make
\end{latex}
\optionyamlrule
\renewcommand\arraystretch{1.3}
\noindent\begin{tabular}{>{\mbox{}\ttfamily\color{bluekeywords}}p{3cm}p{8cm}}
 task          & Specify the task of |make| \\
\end{tabular}
\end{yamlrule}

%------------------------------------------------------------------------------
\begin{yamlrule}
\headyamlrule{dvips}
 The rule calls the converting command |dvips|. 
\begin{latex}
% arara: dvips
\end{latex}
\optionyamlrule
\renewcommand\arraystretch{1.3}
\noindent\begin{tabular}{>{\mbox{}\ttfamily\color{bluekeywords}}p{3cm}p{8cm}}
 outputfile    & Declare the name of the output file. By default the name which
                 is save in the \emph{orb tag} |file| is used.               \\
 expandoptions & Every value of this options will be passed to the compilation 
                 run direct. So you can expand the option list.               \\          
\end{tabular}
\end{yamlrule}

%------------------------------------------------------------------------------
\begin{yamlrule}
\headyamlrule{ps2pdf}
 The rule calls the converting command |ps2pdf|.
\begin{latex}
% arara: ps2pdf
\end{latex}
\optionyamlrule
\renewcommand\arraystretch{1.3}
\noindent\begin{tabular}{>{\mbox{}\ttfamily\color{bluekeywords}}p{3cm}p{8cm}}
 outputfile    & Declare the name of the output file. By default the name which
                 is save in the \emph{orb tag} |file| is used.               \\
 expandoptions & Every value of this options will be passed to the compilation 
                 run direct. So you can expand the option list.               \\          
\end{tabular}
\end{yamlrule}

%------------------------------------------------------------------------------
\begin{yamlrule}
\headyamlrule{removehelpfiles}
 The rule works only with a Unix System. Instead of explaining the options I
will show the definition of the rule.
\begin{yaml}
!config
identifier: removehelpfiles
name: Removing-Help-Files
command: 'rm -f @{remove}'
arguments:
  - identifier: remove
    flag:  '@{value}'
\end{yaml}
\end{yamlrule}

%------------------------------------------------------------------------------
\begin{yamlrule}
\headyamlrule{cleanhelpfiles}
 The rule works only with a Unix System. Instead of explaining the options I
will show the definition of the rule.
\begin{yaml}
!config
identifier: cleanhelpfiles
name: Removing-Help-Files
command: find -type f ! -iname ''*.pdf'' ! -iname ''*.tex'' ! -iname ''*.sty'' 
                      ! -iname ''*.def'' ! -iname ''*.bst'' -exec rm '{}' +
arguments:
  - identifier: keep
    flag:  '@{value}'
\end{yaml}
\end{yamlrule}


% For developers
% -------------------------------------------------
\part{For developers}
\label{part:developers}
% -------------------------------------------------

% Writing compiled rules
% -------------------------------------------------
\chapter{Writing compiled rules}
\label{chap:writingcompiledrules}

% -------------------------------------------------

\end{document}
